declare const symErr: unique symbol;
export type Err<T> = {
    [symErr]: true;
    error: T;
};
export type Result<T, E> = T | Err<E>;
export declare function Err<T>(error: T): Err<T>;
/**
 * Typeguard for Err<T>. Allows the pattern
 * ```ts
 * function getNumSquare(): Result<number, Error> {
 *   const value = getNum();
 *   if (isErr(value)) {
 *     return value; // return as error
 *   }
 *   return value ** 2;
 * }
 * function getNum(): Result<number, Error>
 * ```
 * Since the non-error is not wrapped, it uses a symbol to prevent collisions
 */
export declare function isErr<T, E>(result: Result<T, E>): result is Err<E>;
/**
 * Given an array of results, run a function only on an array of ok results.
 * Returns a new array of results with same length as `results` where the ok
 * value may be Err or T2.
 */
export declare function mapOkResults<T1, T2, E>(results: Result<T1, E>[], fn: (items: T1[]) => Result<T2, E>[]): Result<T2, E>[];
/**
 * See {@link mapOkResults} but `fn` is async
 */
export declare function mapOkResultsAsync<T1, T2, E>(results: Result<T1, E>[], fn: (items: T1[]) => Promise<Result<T2, E>[]>): Promise<Result<T2, E>[]>;
export {};
//# sourceMappingURL=err.d.ts.map