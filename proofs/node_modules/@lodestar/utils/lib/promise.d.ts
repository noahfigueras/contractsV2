import { ArrayToTuple, NonEmptyArray } from "./types.js";
/**
 * While promise t is not finished, call function `fn` per `interval`
 */
export declare function callFnWhenAwait<T>(p: Promise<NonNullable<T>>, fn: () => void, interval: number): Promise<NonNullable<T>>;
export type PromiseResult<T> = {
    promise: Promise<T>;
} & ({
    status: "pending";
} | {
    status: "fulfilled";
    value: T;
    durationMs: number;
} | {
    status: "rejected";
    reason: Error;
    durationMs: number;
});
export type PromiseFulfilledResult<T> = PromiseResult<T> & {
    status: "fulfilled";
};
export type PromiseRejectedResult<T> = PromiseResult<T> & {
    status: "rejected";
};
/**
 * Wrap a promise to an object to track the status and value of the promise
 */
export declare function wrapPromise<T>(promise: PromiseLike<T>): PromiseResult<T>;
type ReturnPromiseWithTuple<Tuple extends NonEmptyArray<PromiseLike<unknown>>> = {
    [Index in keyof ArrayToTuple<Tuple>]: PromiseResult<Awaited<Tuple[Index]>>;
};
/**
 * Two phased approach for resolving promises:
 * - first wait `resolveTimeoutMs` or until all promises settle
 * - then wait `raceTimeoutMs - resolveTimeoutMs` or until at least a single promise resolves
 *
 * Returns a list of promise results, see `PromiseResult`
 */
export declare function resolveOrRacePromises<T extends NonEmptyArray<PromiseLike<unknown>>>(promises: T, { resolveTimeoutMs, raceTimeoutMs, signal, }: {
    resolveTimeoutMs: number;
    raceTimeoutMs: number;
    signal?: AbortSignal;
}): Promise<ReturnPromiseWithTuple<T>> | never;
export {};
//# sourceMappingURL=promise.d.ts.map