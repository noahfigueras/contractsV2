import { ErrorAborted, TimeoutError } from "./errors.js";
/**
 * Wait for a condition to be true
 */
export function waitFor(condition, opts = {}) {
    return new Promise((resolve, reject) => {
        const { interval = 10, timeout = Infinity, signal } = opts;
        if (signal?.aborted) {
            return reject(new ErrorAborted());
        }
        if (condition()) {
            return resolve();
        }
        let onDone = () => { };
        const timeoutId = setTimeout(() => {
            onDone();
            reject(new TimeoutError());
        }, timeout);
        const intervalId = setInterval(() => {
            if (condition()) {
                onDone();
                resolve();
            }
        }, interval);
        const onAbort = () => {
            onDone();
            reject(new ErrorAborted());
        };
        if (signal)
            signal.addEventListener("abort", onAbort);
        onDone = () => {
            clearTimeout(timeoutId);
            clearInterval(intervalId);
            if (signal)
                signal.removeEventListener("abort", onAbort);
        };
    });
}
/**
 * Create a tracker which keeps track of the last time a function was called
 *
 * @param durationMs
 * @returns
 */
export function createElapsedTimeTracker({ minElapsedTime }) {
    // Initialized with undefined as the function has not been called yet
    let lastTimeCalled = undefined;
    function elapsedTimeTracker() {
        const now = Date.now();
        const msSinceLastCall = now - (lastTimeCalled ?? 0);
        lastTimeCalled = now;
        return msSinceLastCall > minElapsedTime;
    }
    return Object.assign(elapsedTimeTracker, {
        get msSinceLastCall() {
            return Date.now() - (lastTimeCalled ?? 0);
        },
    });
}
//# sourceMappingURL=waitFor.js.map