import { ContainerType } from "@chainsafe/ssz";
import { ssz, isSignedBlockContents } from "@lodestar/types";
import { ArrayOf, Schema, WithVersion, reqOnlyBody, ContainerDataExecutionOptimistic, WithExecutionOptimistic, ContainerData, } from "../../../utils/index.js";
import { HttpStatusCode } from "../../../utils/client/httpStatusCode.js";
import { parseAcceptHeader, writeAcceptHeader } from "../../../utils/acceptHeader.js";
import { allForksSignedBlockContentsReqSerializer } from "../../../utils/routes.js";
export var BroadcastValidation;
(function (BroadcastValidation) {
    /*
    NOTE: The value `none` is not part of the spec.
  
    In case a node is configured only with the unknownBlockSync, it needs to know the unknown parent blocks on the network
    to initiate the syncing process. Such cases can be covered only if we publish blocks and make sure no gossip validation
    is performed on those. But this behavior is not the default.
    */
    BroadcastValidation["none"] = "none";
    BroadcastValidation["gossip"] = "gossip";
    BroadcastValidation["consensus"] = "consensus";
    BroadcastValidation["consensusAndEquivocation"] = "consensus_and_equivocation";
})(BroadcastValidation || (BroadcastValidation = {}));
/**
 * Define javascript values for each route
 */
export const routesData = {
    getBlock: { url: "/eth/v1/beacon/blocks/{block_id}", method: "GET" },
    getBlockV2: { url: "/eth/v2/beacon/blocks/{block_id}", method: "GET" },
    getBlockAttestations: { url: "/eth/v1/beacon/blocks/{block_id}/attestations", method: "GET" },
    getBlockHeader: { url: "/eth/v1/beacon/headers/{block_id}", method: "GET" },
    getBlockHeaders: { url: "/eth/v1/beacon/headers", method: "GET" },
    getBlockRoot: { url: "/eth/v1/beacon/blocks/{block_id}/root", method: "GET" },
    publishBlock: { url: "/eth/v1/beacon/blocks", method: "POST" },
    publishBlockV2: { url: "/eth/v2/beacon/blocks", method: "POST" },
    publishBlindedBlock: { url: "/eth/v1/beacon/blinded_blocks", method: "POST" },
    publishBlindedBlockV2: { url: "/eth/v2/beacon/blinded_blocks", method: "POST" },
    getBlobSidecars: { url: "/eth/v1/beacon/blob_sidecars/{block_id}", method: "GET" },
};
export function getReqSerializers(config) {
    const blockIdOnlyReq = {
        writeReq: (block_id) => ({ params: { block_id: String(block_id) } }),
        parseReq: ({ params }) => [params.block_id],
        schema: { params: { block_id: Schema.StringRequired } },
    };
    const getBlockReq = {
        writeReq: (block_id, format) => ({
            params: { block_id: String(block_id) },
            headers: { accept: writeAcceptHeader(format) },
        }),
        parseReq: ({ params, headers }) => [params.block_id, parseAcceptHeader(headers.accept)],
        schema: { params: { block_id: Schema.StringRequired } },
    };
    // Compute block type from JSON payload. See https://github.com/ethereum/eth2.0-APIs/pull/142
    const getSignedBeaconBlockType = (data) => config.getForkTypes(data.message.slot).SignedBeaconBlock;
    const AllForksSignedBlockOrContents = {
        toJson: (data) => isSignedBlockContents(data)
            ? allForksSignedBlockContentsReqSerializer(getSignedBeaconBlockType).toJson(data)
            : getSignedBeaconBlockType(data).toJson(data),
        fromJson: (data) => data.signed_block !== undefined
            ? allForksSignedBlockContentsReqSerializer(getSignedBeaconBlockType).fromJson(data)
            : getSignedBeaconBlockType(data).fromJson(data),
    };
    const getSignedBlindedBeaconBlockType = (data) => config.getBlindedForkTypes(data.message.slot).SignedBeaconBlock;
    const AllForksSignedBlindedBlock = {
        toJson: (data) => getSignedBlindedBeaconBlockType(data).toJson(data),
        fromJson: (data) => getSignedBlindedBeaconBlockType(data).fromJson(data),
    };
    return {
        getBlock: getBlockReq,
        getBlockV2: getBlockReq,
        getBlockAttestations: blockIdOnlyReq,
        getBlockHeader: blockIdOnlyReq,
        getBlockHeaders: {
            writeReq: (filters) => ({ query: { slot: filters?.slot, parent_root: filters?.parentRoot } }),
            parseReq: ({ query }) => [{ slot: query?.slot, parentRoot: query?.parent_root }],
            schema: { query: { slot: Schema.Uint, parent_root: Schema.String } },
        },
        getBlockRoot: blockIdOnlyReq,
        publishBlock: reqOnlyBody(AllForksSignedBlockOrContents, Schema.Object),
        publishBlockV2: {
            writeReq: (item, { broadcastValidation } = {}) => ({
                body: AllForksSignedBlockOrContents.toJson(item),
                query: { broadcast_validation: broadcastValidation },
            }),
            parseReq: ({ body, query }) => [
                AllForksSignedBlockOrContents.fromJson(body),
                { broadcastValidation: query.broadcast_validation },
            ],
            schema: {
                body: Schema.Object,
                query: { broadcast_validation: Schema.String },
            },
        },
        publishBlindedBlock: reqOnlyBody(AllForksSignedBlindedBlock, Schema.Object),
        publishBlindedBlockV2: {
            writeReq: (item, { broadcastValidation }) => ({
                body: AllForksSignedBlindedBlock.toJson(item),
                query: { broadcast_validation: broadcastValidation },
            }),
            parseReq: ({ body, query }) => [
                AllForksSignedBlindedBlock.fromJson(body),
                { broadcastValidation: query.broadcast_validation },
            ],
            schema: {
                body: Schema.Object,
                query: { broadcast_validation: Schema.String },
            },
        },
        getBlobSidecars: {
            writeReq: (block_id, indices) => ({
                params: { block_id: String(block_id) },
                query: { indices },
            }),
            parseReq: ({ params, query }) => [params.block_id, query.indices],
            schema: {
                params: { block_id: Schema.StringRequired },
                query: { indices: Schema.UintArray },
            },
        },
    };
}
export function getReturnTypes() {
    const BeaconHeaderResType = new ContainerType({
        root: ssz.Root,
        canonical: ssz.Boolean,
        header: ssz.phase0.SignedBeaconBlockHeader,
    });
    const RootContainer = new ContainerType({
        root: ssz.Root,
    });
    return {
        getBlock: ContainerData(ssz.phase0.SignedBeaconBlock),
        getBlockV2: WithExecutionOptimistic(WithVersion((fork) => ssz[fork].SignedBeaconBlock)),
        getBlockAttestations: ContainerDataExecutionOptimistic(ArrayOf(ssz.phase0.Attestation)),
        getBlockHeader: ContainerDataExecutionOptimistic(BeaconHeaderResType),
        getBlockHeaders: ContainerDataExecutionOptimistic(ArrayOf(BeaconHeaderResType)),
        getBlockRoot: ContainerDataExecutionOptimistic(RootContainer),
        getBlobSidecars: ContainerDataExecutionOptimistic(ssz.deneb.BlobSidecars),
    };
}
//# sourceMappingURL=block.js.map