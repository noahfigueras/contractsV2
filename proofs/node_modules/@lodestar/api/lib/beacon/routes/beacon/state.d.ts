import { phase0, CommitteeIndex, Slot, ValidatorIndex, Epoch, Root, RootHex } from "@lodestar/types";
import { ApiClientResponse } from "../../../interfaces.js";
import { HttpStatusCode } from "../../../utils/client/httpStatusCode.js";
import { RoutesData, ReturnTypes, ReqSerializers } from "../../../utils/index.js";
export type StateId = RootHex | Slot | "head" | "genesis" | "finalized" | "justified";
export type ValidatorId = string | number;
/**
 * True if the response references an unverified execution payload. Optimistic information may be invalidated at
 * a later time. If the field is not present, assume the False value.
 */
export type ExecutionOptimistic = boolean;
export type ValidatorStatus = "active" | "pending_initialized" | "pending_queued" | "active_ongoing" | "active_exiting" | "active_slashed" | "exited_unslashed" | "exited_slashed" | "withdrawal_possible" | "withdrawal_done";
export type ValidatorFilters = {
    id?: ValidatorId[];
    status?: ValidatorStatus[];
};
export type CommitteesFilters = {
    epoch?: Epoch;
    index?: CommitteeIndex;
    slot?: Slot;
};
export type FinalityCheckpoints = {
    previousJustified: phase0.Checkpoint;
    currentJustified: phase0.Checkpoint;
    finalized: phase0.Checkpoint;
};
export type ValidatorResponse = {
    index: ValidatorIndex;
    balance: number;
    status: ValidatorStatus;
    validator: phase0.Validator;
};
export type ValidatorBalance = {
    index: ValidatorIndex;
    balance: number;
};
export type EpochCommitteeResponse = {
    index: CommitteeIndex;
    slot: Slot;
    validators: ArrayLike<ValidatorIndex>;
};
export type EpochSyncCommitteeResponse = {
    /** all of the validator indices in the current sync committee */
    validators: ValidatorIndex[];
    /** Subcommittee slices of the current sync committee */
    validatorAggregates: ValidatorIndex[][];
};
export type Api = {
    /**
     * Get state SSZ HashTreeRoot
     * Calculates HashTreeRoot for state with given 'stateId'. If stateId is root, same value will be returned.
     *
     * @param stateId State identifier.
     * Can be one of: "head" (canonical head in node's view), "genesis", "finalized", "justified", \<slot\>, \<hex encoded stateRoot with 0x prefix\>.
     */
    getStateRoot(stateId: StateId): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: {
            data: {
                root: Root;
            };
            executionOptimistic: ExecutionOptimistic;
        };
    }, HttpStatusCode.BAD_REQUEST | HttpStatusCode.NOT_FOUND>>;
    /**
     * Get Fork object for requested state
     * Returns [Fork](https://github.com/ethereum/consensus-specs/blob/v1.1.10/specs/phase0/beacon-chain.md#fork) object for state with given 'stateId'.
     * @param stateId State identifier.
     * Can be one of: "head" (canonical head in node's view), "genesis", "finalized", "justified", \<slot\>, \<hex encoded stateRoot with 0x prefix\>.
     */
    getStateFork(stateId: StateId): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: {
            data: phase0.Fork;
            executionOptimistic: ExecutionOptimistic;
        };
    }, HttpStatusCode.BAD_REQUEST | HttpStatusCode.NOT_FOUND>>;
    /**
     * Fetch the RANDAO mix for the requested epoch from the state identified by 'stateId'.
     *
     * @param stateId State identifier.
     * Can be one of: "head" (canonical head in node's view), "genesis", "finalized", "justified", \<slot\>, \<hex encoded stateRoot with 0x prefix\>.
     * @param epoch Fetch randao mix for the given epoch. If an epoch is not specified then the RANDAO mix for the state's current epoch will be returned.
     */
    getStateRandao(stateId: StateId, epoch?: Epoch): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: {
            data: {
                randao: Root;
            };
            executionOptimistic: ExecutionOptimistic;
        };
    }, HttpStatusCode.BAD_REQUEST | HttpStatusCode.NOT_FOUND>>;
    /**
     * Get state finality checkpoints
     * Returns finality checkpoints for state with given 'stateId'.
     * In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root.
     * @param stateId State identifier.
     * Can be one of: "head" (canonical head in node's view), "genesis", "finalized", "justified", \<slot\>, \<hex encoded stateRoot with 0x prefix\>.
     */
    getStateFinalityCheckpoints(stateId: StateId): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: {
            data: FinalityCheckpoints;
            executionOptimistic: ExecutionOptimistic;
        };
    }, HttpStatusCode.BAD_REQUEST | HttpStatusCode.NOT_FOUND>>;
    /**
     * Get validators from state
     * Returns filterable list of validators with their balance, status and index.
     * @param stateId State identifier.
     * Can be one of: "head" (canonical head in node's view), "genesis", "finalized", "justified", \<slot\>, \<hex encoded stateRoot with 0x prefix\>.
     * @param id Either hex encoded public key (with 0x prefix) or validator index
     * @param status [Validator status specification](https://hackmd.io/ofFJ5gOmQpu1jjHilHbdQQ)
     */
    getStateValidators(stateId: StateId, filters?: ValidatorFilters): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: {
            data: ValidatorResponse[];
            executionOptimistic: ExecutionOptimistic;
        };
    }, HttpStatusCode.BAD_REQUEST | HttpStatusCode.NOT_FOUND>>;
    /**
     * Get validator from state by id
     * Returns validator specified by state and id or public key along with status and balance.
     * @param stateId State identifier.
     * Can be one of: "head" (canonical head in node's view), "genesis", "finalized", "justified", \<slot\>, \<hex encoded stateRoot with 0x prefix\>.
     * @param validatorId Either hex encoded public key (with 0x prefix) or validator index
     */
    getStateValidator(stateId: StateId, validatorId: ValidatorId): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: {
            data: ValidatorResponse;
            executionOptimistic: ExecutionOptimistic;
        };
    }, HttpStatusCode.BAD_REQUEST | HttpStatusCode.NOT_FOUND>>;
    /**
     * Get validator balances from state
     * Returns filterable list of validator balances.
     * @param stateId State identifier.
     * Can be one of: "head" (canonical head in node's view), "genesis", "finalized", "justified", \<slot\>, \<hex encoded stateRoot with 0x prefix\>.
     * @param id Either hex encoded public key (with 0x prefix) or validator index
     */
    getStateValidatorBalances(stateId: StateId, indices?: ValidatorId[]): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: {
            data: ValidatorBalance[];
            executionOptimistic: ExecutionOptimistic;
        };
    }, HttpStatusCode.BAD_REQUEST>>;
    /**
     * Get all committees for a state.
     * Retrieves the committees for the given state.
     * @param stateId State identifier.
     * Can be one of: "head" (canonical head in node's view), "genesis", "finalized", "justified", \<slot\>, \<hex encoded stateRoot with 0x prefix\>.
     * @param epoch Fetch committees for the given epoch.  If not present then the committees for the epoch of the state will be obtained.
     * @param index Restrict returned values to those matching the supplied committee index.
     * @param slot Restrict returned values to those matching the supplied slot.
     */
    getEpochCommittees(stateId: StateId, filters?: CommitteesFilters): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: {
            data: EpochCommitteeResponse[];
            executionOptimistic: ExecutionOptimistic;
        };
    }, HttpStatusCode.BAD_REQUEST | HttpStatusCode.NOT_FOUND>>;
    getEpochSyncCommittees(stateId: StateId, epoch?: Epoch): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: {
            data: EpochSyncCommitteeResponse;
            executionOptimistic: ExecutionOptimistic;
        };
    }, HttpStatusCode.BAD_REQUEST | HttpStatusCode.NOT_FOUND>>;
};
/**
 * Define javascript values for each route
 */
export declare const routesData: RoutesData<Api>;
type StateIdOnlyReq = {
    params: {
        state_id: string;
    };
};
export type ReqTypes = {
    getEpochCommittees: {
        params: {
            state_id: StateId;
        };
        query: {
            slot?: number;
            epoch?: number;
            index?: number;
        };
    };
    getEpochSyncCommittees: {
        params: {
            state_id: StateId;
        };
        query: {
            epoch?: number;
        };
    };
    getStateFinalityCheckpoints: StateIdOnlyReq;
    getStateFork: StateIdOnlyReq;
    getStateRoot: StateIdOnlyReq;
    getStateRandao: {
        params: {
            state_id: StateId;
        };
        query: {
            epoch?: number;
        };
    };
    getStateValidator: {
        params: {
            state_id: StateId;
            validator_id: ValidatorId;
        };
    };
    getStateValidators: {
        params: {
            state_id: StateId;
        };
        query: {
            id?: ValidatorId[];
            status?: ValidatorStatus[];
        };
    };
    getStateValidatorBalances: {
        params: {
            state_id: StateId;
        };
        query: {
            id?: ValidatorId[];
        };
    };
};
export declare function getReqSerializers(): ReqSerializers<Api, ReqTypes>;
export declare function getReturnTypes(): ReturnTypes<Api>;
export {};
//# sourceMappingURL=state.d.ts.map