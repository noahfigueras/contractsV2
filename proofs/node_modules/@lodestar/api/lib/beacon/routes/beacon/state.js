import { ContainerType } from "@chainsafe/ssz";
import { ssz, StringType } from "@lodestar/types";
import { HttpStatusCode } from "../../../utils/client/httpStatusCode.js";
import { ArrayOf, ContainerDataExecutionOptimistic, Schema, } from "../../../utils/index.js";
/**
 * Define javascript values for each route
 */
export const routesData = {
    getEpochCommittees: { url: "/eth/v1/beacon/states/{state_id}/committees", method: "GET" },
    getEpochSyncCommittees: { url: "/eth/v1/beacon/states/{state_id}/sync_committees", method: "GET" },
    getStateFinalityCheckpoints: { url: "/eth/v1/beacon/states/{state_id}/finality_checkpoints", method: "GET" },
    getStateFork: { url: "/eth/v1/beacon/states/{state_id}/fork", method: "GET" },
    getStateRoot: { url: "/eth/v1/beacon/states/{state_id}/root", method: "GET" },
    getStateRandao: { url: "/eth/v1/beacon/states/{state_id}/randao", method: "GET" },
    getStateValidator: { url: "/eth/v1/beacon/states/{state_id}/validators/{validator_id}", method: "GET" },
    getStateValidators: { url: "/eth/v1/beacon/states/{state_id}/validators", method: "GET" },
    getStateValidatorBalances: { url: "/eth/v1/beacon/states/{state_id}/validator_balances", method: "GET" },
};
export function getReqSerializers() {
    const stateIdOnlyReq = {
        writeReq: (state_id) => ({ params: { state_id: String(state_id) } }),
        parseReq: ({ params }) => [params.state_id],
        schema: { params: { state_id: Schema.StringRequired } },
    };
    return {
        getEpochCommittees: {
            writeReq: (state_id, filters) => ({ params: { state_id }, query: filters || {} }),
            parseReq: ({ params, query }) => [params.state_id, query],
            schema: {
                params: { state_id: Schema.StringRequired },
                query: { slot: Schema.Uint, epoch: Schema.Uint, index: Schema.Uint },
            },
        },
        getEpochSyncCommittees: {
            writeReq: (state_id, epoch) => ({ params: { state_id }, query: { epoch } }),
            parseReq: ({ params, query }) => [params.state_id, query.epoch],
            schema: {
                params: { state_id: Schema.StringRequired },
                query: { epoch: Schema.Uint },
            },
        },
        getStateFinalityCheckpoints: stateIdOnlyReq,
        getStateFork: stateIdOnlyReq,
        getStateRoot: stateIdOnlyReq,
        getStateRandao: {
            writeReq: (state_id, epoch) => ({ params: { state_id }, query: { epoch } }),
            parseReq: ({ params, query }) => [params.state_id, query.epoch],
            schema: {
                params: { state_id: Schema.StringRequired },
                query: { epoch: Schema.Uint },
            },
        },
        getStateValidator: {
            writeReq: (state_id, validator_id) => ({ params: { state_id, validator_id } }),
            parseReq: ({ params }) => [params.state_id, params.validator_id],
            schema: {
                params: { state_id: Schema.StringRequired, validator_id: Schema.StringRequired },
            },
        },
        getStateValidators: {
            writeReq: (state_id, filters) => ({ params: { state_id }, query: filters || {} }),
            parseReq: ({ params, query }) => [params.state_id, query],
            schema: {
                params: { state_id: Schema.StringRequired },
                query: { id: Schema.UintOrStringArray, status: Schema.StringArray },
            },
        },
        getStateValidatorBalances: {
            writeReq: (state_id, id) => ({ params: { state_id }, query: { id } }),
            parseReq: ({ params, query }) => [params.state_id, query.id],
            schema: {
                params: { state_id: Schema.StringRequired },
                query: { id: Schema.UintOrStringArray },
            },
        },
    };
}
export function getReturnTypes() {
    const RootContainer = new ContainerType({
        root: ssz.Root,
    });
    const RandaoContainer = new ContainerType({
        randao: ssz.Root,
    });
    const FinalityCheckpoints = new ContainerType({
        previousJustified: ssz.phase0.Checkpoint,
        currentJustified: ssz.phase0.Checkpoint,
        finalized: ssz.phase0.Checkpoint,
    }, { jsonCase: "eth2" });
    const ValidatorResponse = new ContainerType({
        index: ssz.ValidatorIndex,
        balance: ssz.UintNum64,
        status: new StringType(),
        validator: ssz.phase0.Validator,
    }, { jsonCase: "eth2" });
    const ValidatorBalance = new ContainerType({
        index: ssz.ValidatorIndex,
        balance: ssz.UintNum64,
    }, { jsonCase: "eth2" });
    const EpochCommitteeResponse = new ContainerType({
        index: ssz.CommitteeIndex,
        slot: ssz.Slot,
        validators: ssz.phase0.CommitteeIndices,
    }, { jsonCase: "eth2" });
    const EpochSyncCommitteesResponse = new ContainerType({
        validators: ArrayOf(ssz.ValidatorIndex),
        validatorAggregates: ArrayOf(ArrayOf(ssz.ValidatorIndex)),
    }, { jsonCase: "eth2" });
    return {
        getStateRoot: ContainerDataExecutionOptimistic(RootContainer),
        getStateFork: ContainerDataExecutionOptimistic(ssz.phase0.Fork),
        getStateRandao: ContainerDataExecutionOptimistic(RandaoContainer),
        getStateFinalityCheckpoints: ContainerDataExecutionOptimistic(FinalityCheckpoints),
        getStateValidators: ContainerDataExecutionOptimistic(ArrayOf(ValidatorResponse)),
        getStateValidator: ContainerDataExecutionOptimistic(ValidatorResponse),
        getStateValidatorBalances: ContainerDataExecutionOptimistic(ArrayOf(ValidatorBalance)),
        getEpochCommittees: ContainerDataExecutionOptimistic(ArrayOf(EpochCommitteeResponse)),
        getEpochSyncCommittees: ContainerDataExecutionOptimistic(EpochSyncCommitteesResponse),
    };
}
//# sourceMappingURL=state.js.map