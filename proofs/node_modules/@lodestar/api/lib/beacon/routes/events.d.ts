import { ContainerType, ValueOf } from "@chainsafe/ssz";
import { Epoch, phase0, capella, Slot, StringType, RootHex, altair, UintNum64, allForks } from "@lodestar/types";
import { ForkName } from "@lodestar/params";
import { RouteDef, TypeJson } from "../../utils/index.js";
import { HttpStatusCode } from "../../utils/client/httpStatusCode.js";
import { ApiClientResponse } from "../../interfaces.js";
export declare const blobSidecarSSE: ContainerType<{
    blockRoot: StringType<string>;
    index: import("@chainsafe/ssz").UintNumberType;
    slot: import("@chainsafe/ssz").UintNumberType;
    kzgCommitment: StringType<string>;
    versionedHash: StringType<string>;
}>;
type BlobSidecarSSE = ValueOf<typeof blobSidecarSSE>;
export declare enum EventType {
    /**
     * The node has finished processing, resulting in a new head. previous_duty_dependent_root is
     * `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch - 1) - 1)` and
     * current_duty_dependent_root is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) - 1)`.
     * Both dependent roots use the genesis block root in the case of underflow.
     */
    head = "head",
    /** The node has received a valid block (from P2P or API) */
    block = "block",
    /** The node has received a valid attestation (from P2P or API) */
    attestation = "attestation",
    /** The node has received a valid voluntary exit (from P2P or API) */
    voluntaryExit = "voluntary_exit",
    /** The node has received a valid proposer slashing (from P2P or API) */
    proposerSlashing = "proposer_slashing",
    /** The node has received a valid attester slashing (from P2P or API) */
    attesterSlashing = "attester_slashing",
    /** The node has received a valid blsToExecutionChange (from P2P or API) */
    blsToExecutionChange = "bls_to_execution_change",
    /** Finalized checkpoint has been updated */
    finalizedCheckpoint = "finalized_checkpoint",
    /** The node has reorganized its chain */
    chainReorg = "chain_reorg",
    /** The node has received a valid sync committee SignedContributionAndProof (from P2P or API) */
    contributionAndProof = "contribution_and_proof",
    /** New or better optimistic header update available */
    lightClientOptimisticUpdate = "light_client_optimistic_update",
    /** New or better finality update available */
    lightClientFinalityUpdate = "light_client_finality_update",
    /** Payload attributes for block proposal */
    payloadAttributes = "payload_attributes",
    /** The node has received a valid blobSidecar (from P2P or API) */
    blobSidecar = "blob_sidecar"
}
export declare const eventTypes: {
    [K in EventType]: K;
};
export type EventData = {
    [EventType.head]: {
        slot: Slot;
        block: RootHex;
        state: RootHex;
        epochTransition: boolean;
        previousDutyDependentRoot: RootHex;
        currentDutyDependentRoot: RootHex;
        executionOptimistic: boolean;
    };
    [EventType.block]: {
        slot: Slot;
        block: RootHex;
        executionOptimistic: boolean;
    };
    [EventType.attestation]: phase0.Attestation;
    [EventType.voluntaryExit]: phase0.SignedVoluntaryExit;
    [EventType.proposerSlashing]: phase0.ProposerSlashing;
    [EventType.attesterSlashing]: phase0.AttesterSlashing;
    [EventType.blsToExecutionChange]: capella.SignedBLSToExecutionChange;
    [EventType.finalizedCheckpoint]: {
        block: RootHex;
        state: RootHex;
        epoch: Epoch;
        executionOptimistic: boolean;
    };
    [EventType.chainReorg]: {
        slot: Slot;
        depth: UintNum64;
        oldHeadBlock: RootHex;
        newHeadBlock: RootHex;
        oldHeadState: RootHex;
        newHeadState: RootHex;
        epoch: Epoch;
        executionOptimistic: boolean;
    };
    [EventType.contributionAndProof]: altair.SignedContributionAndProof;
    [EventType.lightClientOptimisticUpdate]: {
        version: ForkName;
        data: allForks.LightClientOptimisticUpdate;
    };
    [EventType.lightClientFinalityUpdate]: {
        version: ForkName;
        data: allForks.LightClientFinalityUpdate;
    };
    [EventType.payloadAttributes]: {
        version: ForkName;
        data: allForks.SSEPayloadAttributes;
    };
    [EventType.blobSidecar]: BlobSidecarSSE;
};
export type BeaconEvent = {
    [K in EventType]: {
        type: K;
        message: EventData[K];
    };
}[EventType];
export type Api = {
    /**
     * Subscribe to beacon node events
     * Provides endpoint to subscribe to beacon node Server-Sent-Events stream.
     * Consumers should use [eventsource](https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface)
     * implementation to listen on those events.
     *
     * @param topics Event types to subscribe to
     * @returns Opened SSE stream.
     */
    eventstream(topics: EventType[], signal: AbortSignal, onEvent: (event: BeaconEvent) => void): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: void;
    }>>;
};
export declare const routesData: {
    [K in keyof Api]: RouteDef;
};
export type ReqTypes = {
    eventstream: {
        query: {
            topics: EventType[];
        };
    };
};
export declare function getTypeByEvent(): {
    [K in EventType]: TypeJson<EventData[K]>;
};
export declare function getEventSerdes(): {
    toJson: (event: BeaconEvent) => unknown;
    fromJson: (type: EventType, data: unknown) => BeaconEvent["message"];
};
export {};
//# sourceMappingURL=events.d.ts.map