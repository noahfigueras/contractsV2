import { ContainerType } from "@chainsafe/ssz";
import { ssz, StringType } from "@lodestar/types";
import { ArrayOf, Schema, WithVersion, reqEmpty, ContainerDataExecutionOptimistic, WithExecutionOptimistic, ContainerData, } from "../../utils/index.js";
import { HttpStatusCode } from "../../utils/client/httpStatusCode.js";
import { parseAcceptHeader, writeAcceptHeader } from "../../utils/acceptHeader.js";
// See /packages/api/src/routes/index.ts for reasoning and instructions to add new routes
const stringType = new StringType();
const protoNodeSszType = new ContainerType({
    executionPayloadBlockHash: stringType,
    executionPayloadNumber: ssz.UintNum64,
    executionStatus: stringType,
    slot: ssz.Slot,
    blockRoot: stringType,
    parentRoot: stringType,
    stateRoot: stringType,
    targetRoot: stringType,
    justifiedEpoch: ssz.Epoch,
    justifiedRoot: stringType,
    finalizedEpoch: ssz.Epoch,
    finalizedRoot: stringType,
    unrealizedJustifiedEpoch: ssz.Epoch,
    unrealizedJustifiedRoot: stringType,
    unrealizedFinalizedEpoch: ssz.Epoch,
    unrealizedFinalizedRoot: stringType,
    parent: stringType,
    weight: ssz.Uint32,
    bestChild: stringType,
    bestDescendant: stringType,
}, { jsonCase: "eth2" });
export const routesData = {
    getDebugChainHeads: { url: "/eth/v1/debug/beacon/heads", method: "GET" },
    getDebugChainHeadsV2: { url: "/eth/v2/debug/beacon/heads", method: "GET" },
    getProtoArrayNodes: { url: "/eth/v0/debug/forkchoice", method: "GET" },
    getState: { url: "/eth/v1/debug/beacon/states/{state_id}", method: "GET" },
    getStateV2: { url: "/eth/v2/debug/beacon/states/{state_id}", method: "GET" },
};
export function getReqSerializers() {
    const getState = {
        writeReq: (state_id, format) => ({
            params: { state_id: String(state_id) },
            headers: { accept: writeAcceptHeader(format) },
        }),
        parseReq: ({ params, headers }) => [params.state_id, parseAcceptHeader(headers.accept)],
        schema: { params: { state_id: Schema.StringRequired } },
    };
    return {
        getDebugChainHeads: reqEmpty,
        getDebugChainHeadsV2: reqEmpty,
        getProtoArrayNodes: reqEmpty,
        getState: getState,
        getStateV2: getState,
    };
}
export function getReturnTypes() {
    const SlotRoot = new ContainerType({
        slot: ssz.Slot,
        root: stringType,
    }, { jsonCase: "eth2" });
    const SlotRootExecutionOptimistic = new ContainerType({
        slot: ssz.Slot,
        root: stringType,
        executionOptimistic: ssz.Boolean,
    }, { jsonCase: "eth2" });
    return {
        getDebugChainHeads: ContainerData(ArrayOf(SlotRoot)),
        getDebugChainHeadsV2: ContainerData(ArrayOf(SlotRootExecutionOptimistic)),
        getProtoArrayNodes: ContainerData(ArrayOf(protoNodeSszType)),
        getState: ContainerDataExecutionOptimistic(ssz.phase0.BeaconState),
        getStateV2: WithExecutionOptimistic(
        // Teku returns fork as UPPERCASE
        WithVersion((fork) => ssz[fork.toLowerCase()].BeaconState)),
    };
}
//# sourceMappingURL=debug.js.map