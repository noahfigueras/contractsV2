import { ContainerType, fromHexString, toHexString } from "@chainsafe/ssz";
import { ForkName, isForkBlobs, isForkExecution } from "@lodestar/params";
import { ssz, StringType, ProducedBlockSource, } from "@lodestar/types";
import { HttpStatusCode } from "../../utils/client/httpStatusCode.js";
import { ArrayOf, Schema, WithVersion, WithBlockValues, reqOnlyBody, jsonType, ContainerDataExecutionOptimistic, ContainerData, } from "../../utils/index.js";
import { fromU64Str, fromGraffitiHex, toU64Str, toGraffitiHex } from "../../utils/serdes.js";
import { allForksBlockContentsResSerializer } from "../../utils/routes.js";
export var BuilderSelection;
(function (BuilderSelection) {
    BuilderSelection["BuilderAlways"] = "builderalways";
    BuilderSelection["ExecutionAlways"] = "executionalways";
    BuilderSelection["MaxProfit"] = "maxprofit";
    /** Only activate builder flow for DVT block proposal protocols */
    BuilderSelection["BuilderOnly"] = "builderonly";
    /** Only builds execution block*/
    BuilderSelection["ExecutionOnly"] = "executiononly";
})(BuilderSelection || (BuilderSelection = {}));
/**
 * Define javascript values for each route
 */
export const routesData = {
    getAttesterDuties: { url: "/eth/v1/validator/duties/attester/{epoch}", method: "POST" },
    getProposerDuties: { url: "/eth/v1/validator/duties/proposer/{epoch}", method: "GET" },
    getSyncCommitteeDuties: { url: "/eth/v1/validator/duties/sync/{epoch}", method: "POST" },
    produceBlock: { url: "/eth/v1/validator/blocks/{slot}", method: "GET" },
    produceBlockV2: { url: "/eth/v2/validator/blocks/{slot}", method: "GET" },
    produceBlockV3: { url: "/eth/v3/validator/blocks/{slot}", method: "GET" },
    produceBlindedBlock: { url: "/eth/v1/validator/blinded_blocks/{slot}", method: "GET" },
    produceAttestationData: { url: "/eth/v1/validator/attestation_data", method: "GET" },
    produceSyncCommitteeContribution: { url: "/eth/v1/validator/sync_committee_contribution", method: "GET" },
    getAggregatedAttestation: { url: "/eth/v1/validator/aggregate_attestation", method: "GET" },
    publishAggregateAndProofs: { url: "/eth/v1/validator/aggregate_and_proofs", method: "POST" },
    publishContributionAndProofs: { url: "/eth/v1/validator/contribution_and_proofs", method: "POST" },
    prepareBeaconCommitteeSubnet: { url: "/eth/v1/validator/beacon_committee_subscriptions", method: "POST" },
    prepareSyncCommitteeSubnets: { url: "/eth/v1/validator/sync_committee_subscriptions", method: "POST" },
    prepareBeaconProposer: { url: "/eth/v1/validator/prepare_beacon_proposer", method: "POST" },
    submitBeaconCommitteeSelections: { url: "/eth/v1/validator/beacon_committee_selections", method: "POST" },
    submitSyncCommitteeSelections: { url: "/eth/v1/validator/sync_committee_selections", method: "POST" },
    getLiveness: { url: "/eth/v1/validator/liveness/{epoch}", method: "POST" },
    registerValidator: { url: "/eth/v1/validator/register_validator", method: "POST" },
};
const BeaconCommitteeSelection = new ContainerType({
    validatorIndex: ssz.ValidatorIndex,
    slot: ssz.Slot,
    selectionProof: ssz.BLSSignature,
}, { jsonCase: "eth2" });
const SyncCommitteeSelection = new ContainerType({
    validatorIndex: ssz.ValidatorIndex,
    slot: ssz.Slot,
    subcommitteeIndex: ssz.SubcommitteeIndex,
    selectionProof: ssz.BLSSignature,
}, { jsonCase: "eth2" });
export function getReqSerializers() {
    const BeaconCommitteeSubscription = new ContainerType({
        validatorIndex: ssz.ValidatorIndex,
        committeeIndex: ssz.CommitteeIndex,
        committeesAtSlot: ssz.Slot,
        slot: ssz.Slot,
        isAggregator: ssz.Boolean,
    }, { jsonCase: "eth2" });
    const SyncCommitteeSubscription = new ContainerType({
        validatorIndex: ssz.ValidatorIndex,
        syncCommitteeIndices: ArrayOf(ssz.CommitteeIndex),
        untilEpoch: ssz.Epoch,
    }, { jsonCase: "eth2" });
    const produceBlockV3 = {
        writeReq: (slot, randaoReveal, graffiti, skipRandaoVerification, opts) => ({
            params: { slot },
            query: {
                randao_reveal: toHexString(randaoReveal),
                graffiti: toGraffitiHex(graffiti),
                fee_recipient: opts?.feeRecipient,
                skip_randao_verification: skipRandaoVerification,
                builder_selection: opts?.builderSelection,
                builder_boost_factor: opts?.builderBoostFactor?.toString(),
                strict_fee_recipient_check: opts?.strictFeeRecipientCheck,
                blinded_local: opts?.blindedLocal,
            },
        }),
        parseReq: ({ params, query }) => [
            params.slot,
            fromHexString(query.randao_reveal),
            fromGraffitiHex(query.graffiti),
            query.skip_randao_verification,
            {
                feeRecipient: query.fee_recipient,
                builderSelection: query.builder_selection,
                builderBoostFactor: parseBuilderBoostFactor(query.builder_boost_factor),
                strictFeeRecipientCheck: query.strict_fee_recipient_check,
                blindedLocal: query.blinded_local,
            },
        ],
        schema: {
            params: { slot: Schema.UintRequired },
            query: {
                randao_reveal: Schema.StringRequired,
                graffiti: Schema.String,
                fee_recipient: Schema.String,
                skip_randao_verification: Schema.Boolean,
                builder_selection: Schema.String,
                builder_boost_factor: Schema.String,
                strict_fee_recipient_check: Schema.Boolean,
                blinded_local: Schema.Boolean,
            },
        },
    };
    return {
        getAttesterDuties: {
            writeReq: (epoch, indexes) => ({ params: { epoch }, body: indexes.map((i) => toU64Str(i)) }),
            parseReq: ({ params, body }) => [params.epoch, body.map((i) => fromU64Str(i))],
            schema: {
                params: { epoch: Schema.UintRequired },
                body: Schema.StringArray,
            },
        },
        getProposerDuties: {
            writeReq: (epoch) => ({ params: { epoch } }),
            parseReq: ({ params }) => [params.epoch],
            schema: {
                params: { epoch: Schema.UintRequired },
            },
        },
        getSyncCommitteeDuties: {
            writeReq: (epoch, indexes) => ({ params: { epoch }, body: indexes.map((i) => toU64Str(i)) }),
            parseReq: ({ params, body }) => [params.epoch, body.map((i) => fromU64Str(i))],
            schema: {
                params: { epoch: Schema.UintRequired },
                body: Schema.StringArray,
            },
        },
        produceBlock: produceBlockV3,
        produceBlockV2: produceBlockV3,
        produceBlockV3,
        produceBlindedBlock: produceBlockV3,
        produceAttestationData: {
            writeReq: (index, slot) => ({ query: { slot, committee_index: index } }),
            parseReq: ({ query }) => [query.committee_index, query.slot],
            schema: {
                query: { slot: Schema.UintRequired, committee_index: Schema.UintRequired },
            },
        },
        produceSyncCommitteeContribution: {
            writeReq: (slot, index, root) => ({
                query: { slot, subcommittee_index: index, beacon_block_root: toHexString(root) },
            }),
            parseReq: ({ query }) => [query.slot, query.subcommittee_index, fromHexString(query.beacon_block_root)],
            schema: {
                query: {
                    slot: Schema.UintRequired,
                    subcommittee_index: Schema.UintRequired,
                    beacon_block_root: Schema.StringRequired,
                },
            },
        },
        getAggregatedAttestation: {
            writeReq: (root, slot) => ({ query: { attestation_data_root: toHexString(root), slot } }),
            parseReq: ({ query }) => [fromHexString(query.attestation_data_root), query.slot],
            schema: {
                query: { attestation_data_root: Schema.StringRequired, slot: Schema.UintRequired },
            },
        },
        publishAggregateAndProofs: reqOnlyBody(ArrayOf(ssz.phase0.SignedAggregateAndProof), Schema.ObjectArray),
        publishContributionAndProofs: reqOnlyBody(ArrayOf(ssz.altair.SignedContributionAndProof), Schema.ObjectArray),
        prepareBeaconCommitteeSubnet: reqOnlyBody(ArrayOf(BeaconCommitteeSubscription), Schema.ObjectArray),
        prepareSyncCommitteeSubnets: reqOnlyBody(ArrayOf(SyncCommitteeSubscription), Schema.ObjectArray),
        prepareBeaconProposer: {
            writeReq: (items) => ({ body: items.map((item) => jsonType("snake").toJson(item)) }),
            parseReq: ({ body }) => [
                body.map((item) => jsonType("snake").fromJson(item)),
            ],
            schema: { body: Schema.ObjectArray },
        },
        submitBeaconCommitteeSelections: {
            writeReq: (items) => ({ body: ArrayOf(BeaconCommitteeSelection).toJson(items) }),
            parseReq: () => [[]],
        },
        submitSyncCommitteeSelections: {
            writeReq: (items) => ({ body: ArrayOf(SyncCommitteeSelection).toJson(items) }),
            parseReq: () => [[]],
        },
        getLiveness: {
            writeReq: (epoch, indexes) => ({ params: { epoch }, body: indexes.map((i) => toU64Str(i)) }),
            parseReq: ({ params, body }) => [params.epoch, body.map((i) => fromU64Str(i))],
            schema: {
                params: { epoch: Schema.UintRequired },
                body: Schema.StringArray,
            },
        },
        registerValidator: reqOnlyBody(ArrayOf(ssz.bellatrix.SignedValidatorRegistrationV1), Schema.ObjectArray),
    };
}
export function getReturnTypes() {
    const rootHexType = new StringType();
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    const WithDependentRootExecutionOptimistic = (dataType) => new ContainerType({
        executionOptimistic: ssz.Boolean,
        data: dataType,
        dependentRoot: rootHexType,
    }, { jsonCase: "eth2" });
    const AttesterDuty = new ContainerType({
        pubkey: ssz.BLSPubkey,
        validatorIndex: ssz.ValidatorIndex,
        committeeIndex: ssz.CommitteeIndex,
        committeeLength: ssz.UintNum64,
        committeesAtSlot: ssz.UintNum64,
        validatorCommitteeIndex: ssz.UintNum64,
        slot: ssz.Slot,
    }, { jsonCase: "eth2" });
    const ProposerDuty = new ContainerType({
        slot: ssz.Slot,
        validatorIndex: ssz.ValidatorIndex,
        pubkey: ssz.BLSPubkey,
    }, { jsonCase: "eth2" });
    const SyncDuty = new ContainerType({
        pubkey: ssz.BLSPubkey,
        validatorIndex: ssz.ValidatorIndex,
        validatorSyncCommitteeIndices: ArrayOf(ssz.UintNum64),
    }, { jsonCase: "eth2" });
    const produceBlockOrContents = WithBlockValues(WithVersion((fork) => isForkBlobs(fork) ? allForksBlockContentsResSerializer(fork) : ssz[fork].BeaconBlock));
    const produceBlindedBlock = WithBlockValues(WithVersion((fork) => ssz.allForksBlinded[isForkExecution(fork) ? fork : ForkName.bellatrix].BeaconBlock));
    return {
        getAttesterDuties: WithDependentRootExecutionOptimistic(ArrayOf(AttesterDuty)),
        getProposerDuties: WithDependentRootExecutionOptimistic(ArrayOf(ProposerDuty)),
        getSyncCommitteeDuties: ContainerDataExecutionOptimistic(ArrayOf(SyncDuty)),
        produceBlock: ContainerData(ssz.phase0.BeaconBlock),
        produceBlockV2: produceBlockOrContents,
        produceBlockV3: {
            toJson: (data) => {
                if (data.executionPayloadBlinded) {
                    return {
                        execution_payload_blinded: true,
                        execution_payload_source: data.executionPayloadSource,
                        ...produceBlindedBlock.toJson(data),
                    };
                }
                else {
                    return {
                        execution_payload_blinded: false,
                        execution_payload_source: data.executionPayloadSource,
                        ...produceBlockOrContents.toJson(data),
                    };
                }
            },
            fromJson: (data) => {
                const executionPayloadBlinded = data.execution_payload_blinded;
                if (executionPayloadBlinded === undefined) {
                    throw Error(`Invalid executionPayloadBlinded=${executionPayloadBlinded} for fromJson deserialization`);
                }
                // extract source from the data and assign defaults in the spec complaint manner if not present in response
                const executionPayloadSource = data.execution_payload_source ??
                    (executionPayloadBlinded ? ProducedBlockSource.builder : ProducedBlockSource.engine);
                if (executionPayloadBlinded) {
                    return { executionPayloadBlinded, executionPayloadSource, ...produceBlindedBlock.fromJson(data) };
                }
                else {
                    return { executionPayloadBlinded, executionPayloadSource, ...produceBlockOrContents.fromJson(data) };
                }
            },
        },
        produceBlindedBlock,
        produceAttestationData: ContainerData(ssz.phase0.AttestationData),
        produceSyncCommitteeContribution: ContainerData(ssz.altair.SyncCommitteeContribution),
        getAggregatedAttestation: ContainerData(ssz.phase0.Attestation),
        submitBeaconCommitteeSelections: ContainerData(ArrayOf(BeaconCommitteeSelection)),
        submitSyncCommitteeSelections: ContainerData(ArrayOf(SyncCommitteeSelection)),
        getLiveness: jsonType("snake"),
    };
}
function parseBuilderBoostFactor(builderBoostFactorInput) {
    return builderBoostFactorInput !== undefined ? BigInt(builderBoostFactorInput) : undefined;
}
//# sourceMappingURL=validator.js.map