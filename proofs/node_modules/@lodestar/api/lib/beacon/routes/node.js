import { ContainerType } from "@chainsafe/ssz";
import { ssz, StringType } from "@lodestar/types";
import { ArrayOf, reqEmpty, jsonType, Schema, ContainerData, } from "../../utils/index.js";
import { HttpStatusCode } from "../../utils/client/httpStatusCode.js";
export var NodeHealth;
(function (NodeHealth) {
    NodeHealth[NodeHealth["READY"] = 200] = "READY";
    NodeHealth[NodeHealth["SYNCING"] = 206] = "SYNCING";
    NodeHealth[NodeHealth["NOT_INITIALIZED_OR_ISSUES"] = 503] = "NOT_INITIALIZED_OR_ISSUES";
})(NodeHealth || (NodeHealth = {}));
export const routesData = {
    getNetworkIdentity: { url: "/eth/v1/node/identity", method: "GET" },
    getPeers: { url: "/eth/v1/node/peers", method: "GET" },
    getPeer: { url: "/eth/v1/node/peers/{peer_id}", method: "GET" },
    getPeerCount: { url: "/eth/v1/node/peer_count", method: "GET" },
    getNodeVersion: { url: "/eth/v1/node/version", method: "GET" },
    getSyncingStatus: { url: "/eth/v1/node/syncing", method: "GET" },
    getHealth: { url: "/eth/v1/node/health", method: "GET" },
};
export function getReqSerializers() {
    return {
        getNetworkIdentity: reqEmpty,
        getPeers: {
            writeReq: (filters) => ({ query: filters || {} }),
            parseReq: ({ query }) => [query],
            schema: { query: { state: Schema.StringArray, direction: Schema.StringArray } },
        },
        getPeer: {
            writeReq: (peer_id) => ({ params: { peer_id } }),
            parseReq: ({ params }) => [params.peer_id],
            schema: { params: { peer_id: Schema.StringRequired } },
        },
        getPeerCount: reqEmpty,
        getNodeVersion: reqEmpty,
        getSyncingStatus: reqEmpty,
        getHealth: {
            writeReq: (options) => ({
                query: options?.syncingStatus !== undefined ? { syncing_status: options.syncingStatus } : {},
            }),
            parseReq: ({ query }) => [{ syncingStatus: query.syncing_status }],
            schema: { query: { syncing_status: Schema.Uint } },
        },
    };
}
export function getReturnTypes() {
    const stringType = new StringType();
    const NetworkIdentity = new ContainerType({
        peerId: stringType,
        enr: stringType,
        p2pAddresses: ArrayOf(stringType),
        discoveryAddresses: ArrayOf(stringType),
        metadata: ssz.altair.Metadata,
    }, { jsonCase: "eth2" });
    const PeerCount = new ContainerType({
        disconnected: ssz.UintNum64,
        connecting: ssz.UintNum64,
        connected: ssz.UintNum64,
        disconnecting: ssz.UintNum64,
    }, { jsonCase: "eth2" });
    return {
        //
        // TODO: Consider just converting the JSON case without custom types
        //
        getNetworkIdentity: ContainerData(NetworkIdentity),
        // All these types don't contain any BigInt nor Buffer instances.
        // Use jsonType() to translate the casing in a generic way.
        getPeers: jsonType("snake"),
        getPeer: jsonType("snake"),
        getPeerCount: ContainerData(PeerCount),
        getNodeVersion: jsonType("snake"),
        getSyncingStatus: jsonType("snake"),
    };
}
//# sourceMappingURL=node.js.map