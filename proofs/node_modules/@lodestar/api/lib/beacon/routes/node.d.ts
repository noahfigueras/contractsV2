import { allForks } from "@lodestar/types";
import { ReturnTypes, RoutesData, ReqSerializers, ReqEmpty } from "../../utils/index.js";
import { HttpStatusCode } from "../../utils/client/httpStatusCode.js";
import { ApiClientResponse } from "../../interfaces.js";
export type NetworkIdentity = {
    /** Cryptographic hash of a peerâ€™s public key. [Read more](https://docs.libp2p.io/concepts/peer-id/) */
    peerId: string;
    /** Ethereum node record. [Read more](https://eips.ethereum.org/EIPS/eip-778) */
    enr: string;
    p2pAddresses: string[];
    discoveryAddresses: string[];
    /** Based on Ethereum Consensus [Metadata object](https://github.com/ethereum/consensus-specs/blob/v1.1.10/specs/phase0/p2p-interface.md#metadata) */
    metadata: allForks.Metadata;
};
export type PeerState = "disconnected" | "connecting" | "connected" | "disconnecting";
export type PeerDirection = "inbound" | "outbound";
export type NodePeer = {
    peerId: string;
    enr: string;
    lastSeenP2pAddress: string;
    state: PeerState;
    direction: PeerDirection | null;
};
export type PeerCount = {
    disconnected: number;
    connecting: number;
    connected: number;
    disconnecting: number;
};
export type FilterGetPeers = {
    state?: PeerState[];
    direction?: PeerDirection[];
};
export type SyncingStatus = {
    /** Head slot node is trying to reach */
    headSlot: string;
    /** How many slots node needs to process to reach head. 0 if synced. */
    syncDistance: string;
    /** Set to true if the node is syncing, false if the node is synced. */
    isSyncing: boolean;
    /** Set to true if the node is optimistically tracking head. */
    isOptimistic: boolean;
    /** Set to true if the connected el client is offline */
    elOffline: boolean;
};
export declare enum NodeHealth {
    READY = 200,
    SYNCING = 206,
    NOT_INITIALIZED_OR_ISSUES = 503
}
export type NodeHealthOptions = {
    syncingStatus?: number;
};
/**
 * Read information about the beacon node.
 */
export type Api = {
    /**
     * Get node network identity
     * Retrieves data about the node's network presence
     */
    getNetworkIdentity: () => Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: {
            data: NetworkIdentity;
        };
    }>>;
    /**
     * Get node network peers
     * Retrieves data about the node's network peers. By default this returns all peers. Multiple query params are combined using AND conditions
     * @param state
     * @param direction
     */
    getPeers(filters?: FilterGetPeers): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: {
            data: NodePeer[];
            meta: {
                count: number;
            };
        };
    }>>;
    /**
     * Get peer
     * Retrieves data about the given peer
     * @param peerId
     */
    getPeer(peerId: string): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: {
            data: NodePeer;
        };
    }, HttpStatusCode.BAD_REQUEST | HttpStatusCode.NOT_FOUND>>;
    /**
     * Get peer count
     * Retrieves number of known peers.
     */
    getPeerCount(): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: {
            data: PeerCount;
        };
    }>>;
    /**
     * Get version string of the running beacon node.
     * Requests that the beacon node identify information about its implementation in a format similar to a [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) field.
     */
    getNodeVersion(): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: {
            data: {
                version: string;
            };
        };
    }>>;
    /**
     * Get node syncing status
     * Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to.
     */
    getSyncingStatus(): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: {
            data: SyncingStatus;
        };
    }>>;
    /**
     * Get health check
     * Returns node health status in http status codes. Useful for load balancers.
     */
    getHealth(options?: NodeHealthOptions): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: void;
        [HttpStatusCode.PARTIAL_CONTENT]: void;
    }, HttpStatusCode.BAD_REQUEST | HttpStatusCode.SERVICE_UNAVAILABLE>>;
};
export declare const routesData: RoutesData<Api>;
export type ReqTypes = {
    getNetworkIdentity: ReqEmpty;
    getPeers: {
        query: {
            state?: PeerState[];
            direction?: PeerDirection[];
        };
    };
    getPeer: {
        params: {
            peer_id: string;
        };
    };
    getPeerCount: ReqEmpty;
    getNodeVersion: ReqEmpty;
    getSyncingStatus: ReqEmpty;
    getHealth: {
        query: {
            syncing_status?: number;
        };
    };
};
export declare function getReqSerializers(): ReqSerializers<Api, ReqTypes>;
export declare function getReturnTypes(): ReturnTypes<Api>;
//# sourceMappingURL=node.d.ts.map