import { ContainerType } from "@chainsafe/ssz";
import { ssz, StringType } from "@lodestar/types";
import { isForkExecution, isForkLightClient } from "@lodestar/params";
import { WithVersion } from "../../utils/index.js";
import { HttpStatusCode } from "../../utils/client/httpStatusCode.js";
const stringType = new StringType();
export const blobSidecarSSE = new ContainerType({
    blockRoot: stringType,
    index: ssz.BlobIndex,
    slot: ssz.Slot,
    kzgCommitment: stringType,
    versionedHash: stringType,
}, { typeName: "BlobSidecarSSE", jsonCase: "eth2" });
// See /packages/api/src/routes/index.ts for reasoning and instructions to add new routes
export var EventType;
(function (EventType) {
    /**
     * The node has finished processing, resulting in a new head. previous_duty_dependent_root is
     * `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch - 1) - 1)` and
     * current_duty_dependent_root is `get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) - 1)`.
     * Both dependent roots use the genesis block root in the case of underflow.
     */
    EventType["head"] = "head";
    /** The node has received a valid block (from P2P or API) */
    EventType["block"] = "block";
    /** The node has received a valid attestation (from P2P or API) */
    EventType["attestation"] = "attestation";
    /** The node has received a valid voluntary exit (from P2P or API) */
    EventType["voluntaryExit"] = "voluntary_exit";
    /** The node has received a valid proposer slashing (from P2P or API) */
    EventType["proposerSlashing"] = "proposer_slashing";
    /** The node has received a valid attester slashing (from P2P or API) */
    EventType["attesterSlashing"] = "attester_slashing";
    /** The node has received a valid blsToExecutionChange (from P2P or API) */
    EventType["blsToExecutionChange"] = "bls_to_execution_change";
    /** Finalized checkpoint has been updated */
    EventType["finalizedCheckpoint"] = "finalized_checkpoint";
    /** The node has reorganized its chain */
    EventType["chainReorg"] = "chain_reorg";
    /** The node has received a valid sync committee SignedContributionAndProof (from P2P or API) */
    EventType["contributionAndProof"] = "contribution_and_proof";
    /** New or better optimistic header update available */
    EventType["lightClientOptimisticUpdate"] = "light_client_optimistic_update";
    /** New or better finality update available */
    EventType["lightClientFinalityUpdate"] = "light_client_finality_update";
    /** Payload attributes for block proposal */
    EventType["payloadAttributes"] = "payload_attributes";
    /** The node has received a valid blobSidecar (from P2P or API) */
    EventType["blobSidecar"] = "blob_sidecar";
})(EventType || (EventType = {}));
export const eventTypes = {
    [EventType.head]: EventType.head,
    [EventType.block]: EventType.block,
    [EventType.attestation]: EventType.attestation,
    [EventType.voluntaryExit]: EventType.voluntaryExit,
    [EventType.proposerSlashing]: EventType.proposerSlashing,
    [EventType.attesterSlashing]: EventType.attesterSlashing,
    [EventType.blsToExecutionChange]: EventType.blsToExecutionChange,
    [EventType.finalizedCheckpoint]: EventType.finalizedCheckpoint,
    [EventType.chainReorg]: EventType.chainReorg,
    [EventType.contributionAndProof]: EventType.contributionAndProof,
    [EventType.lightClientOptimisticUpdate]: EventType.lightClientOptimisticUpdate,
    [EventType.lightClientFinalityUpdate]: EventType.lightClientFinalityUpdate,
    [EventType.payloadAttributes]: EventType.payloadAttributes,
    [EventType.blobSidecar]: EventType.blobSidecar,
};
export const routesData = {
    eventstream: { url: "/eth/v1/events", method: "GET" },
};
// It doesn't make sense to define a getReqSerializers() here given the exotic argument of eventstream()
// The request is very simple: (topics) => {query: {topics}}, and the test will ensure compatibility server - client
export function getTypeByEvent() {
    const getLightClientType = (fork) => {
        if (!isForkLightClient(fork)) {
            throw Error(`Invalid fork=${fork} for lightclient fork types`);
        }
        return ssz.allForksLightClient[fork];
    };
    return {
        [EventType.head]: new ContainerType({
            slot: ssz.Slot,
            block: stringType,
            state: stringType,
            epochTransition: ssz.Boolean,
            previousDutyDependentRoot: stringType,
            currentDutyDependentRoot: stringType,
            executionOptimistic: ssz.Boolean,
        }, { jsonCase: "eth2" }),
        [EventType.block]: new ContainerType({
            slot: ssz.Slot,
            block: stringType,
            executionOptimistic: ssz.Boolean,
        }, { jsonCase: "eth2" }),
        [EventType.attestation]: ssz.phase0.Attestation,
        [EventType.voluntaryExit]: ssz.phase0.SignedVoluntaryExit,
        [EventType.proposerSlashing]: ssz.phase0.ProposerSlashing,
        [EventType.attesterSlashing]: ssz.phase0.AttesterSlashing,
        [EventType.blsToExecutionChange]: ssz.capella.SignedBLSToExecutionChange,
        [EventType.finalizedCheckpoint]: new ContainerType({
            block: stringType,
            state: stringType,
            epoch: ssz.Epoch,
            executionOptimistic: ssz.Boolean,
        }, { jsonCase: "eth2" }),
        [EventType.chainReorg]: new ContainerType({
            slot: ssz.Slot,
            depth: ssz.UintNum64,
            oldHeadBlock: stringType,
            newHeadBlock: stringType,
            oldHeadState: stringType,
            newHeadState: stringType,
            epoch: ssz.Epoch,
            executionOptimistic: ssz.Boolean,
        }, { jsonCase: "eth2" }),
        [EventType.contributionAndProof]: ssz.altair.SignedContributionAndProof,
        [EventType.payloadAttributes]: WithVersion((fork) => isForkExecution(fork) ? ssz.allForksExecution[fork].SSEPayloadAttributes : ssz.bellatrix.SSEPayloadAttributes),
        [EventType.blobSidecar]: blobSidecarSSE,
        [EventType.lightClientOptimisticUpdate]: WithVersion((fork) => getLightClientType(fork).LightClientOptimisticUpdate),
        [EventType.lightClientFinalityUpdate]: WithVersion((fork) => getLightClientType(fork).LightClientFinalityUpdate),
    };
}
// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
export function getEventSerdes() {
    const typeByEvent = getTypeByEvent();
    return {
        toJson: (event) => {
            const eventType = typeByEvent[event.type];
            return eventType.toJson(event.message);
        },
        fromJson: (type, data) => {
            const eventType = typeByEvent[type];
            return eventType.fromJson(data);
        },
    };
}
//# sourceMappingURL=events.js.map