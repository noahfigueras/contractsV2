import { ContainerType } from "@chainsafe/ssz";
import { ssz, stringType } from "@lodestar/types";
import { HttpStatusCode } from "../utils/client/httpStatusCode.js";
import { Schema, reqEmpty, jsonType, ContainerData, } from "../utils/index.js";
export var ImportStatus;
(function (ImportStatus) {
    /** Keystore successfully decrypted and imported to keymanager permanent storage */
    ImportStatus["imported"] = "imported";
    /** Keystore's pubkey is already known to the keymanager */
    ImportStatus["duplicate"] = "duplicate";
    /** Any other status different to the above: decrypting error, I/O errors, etc. */
    ImportStatus["error"] = "error";
})(ImportStatus || (ImportStatus = {}));
export var DeletionStatus;
(function (DeletionStatus) {
    /** key was active and removed */
    DeletionStatus["deleted"] = "deleted";
    /** slashing protection data returned but key was not active */
    DeletionStatus["not_active"] = "not_active";
    /** key was not found to be removed, and no slashing data can be returned */
    DeletionStatus["not_found"] = "not_found";
    /** unexpected condition meant the key could not be removed (the key was actually found, but we couldn't stop using it) - this would be a sign that making it active elsewhere would almost certainly cause you headaches / slashing conditions etc. */
    DeletionStatus["error"] = "error";
})(DeletionStatus || (DeletionStatus = {}));
export var ImportRemoteKeyStatus;
(function (ImportRemoteKeyStatus) {
    /** Remote key successfully imported to validator client permanent storage */
    ImportRemoteKeyStatus["imported"] = "imported";
    /** Remote key's pubkey is already known to the validator client */
    ImportRemoteKeyStatus["duplicate"] = "duplicate";
    /** Any other status different to the above: I/O errors, etc. */
    ImportRemoteKeyStatus["error"] = "error";
})(ImportRemoteKeyStatus || (ImportRemoteKeyStatus = {}));
export var DeleteRemoteKeyStatus;
(function (DeleteRemoteKeyStatus) {
    /** key was active and removed */
    DeleteRemoteKeyStatus["deleted"] = "deleted";
    /** key was not found to be removed */
    DeleteRemoteKeyStatus["not_found"] = "not_found";
    /**
     * unexpected condition meant the key could not be removed (the key was actually found,
     * but we couldn't stop using it) - this would be a sign that making it active elsewhere would
     * almost certainly cause you headaches / slashing conditions etc.
     */
    DeleteRemoteKeyStatus["error"] = "error";
})(DeleteRemoteKeyStatus || (DeleteRemoteKeyStatus = {}));
export const routesData = {
    listKeys: { url: "/eth/v1/keystores", method: "GET" },
    importKeystores: { url: "/eth/v1/keystores", method: "POST" },
    deleteKeys: { url: "/eth/v1/keystores", method: "DELETE" },
    listRemoteKeys: { url: "/eth/v1/remotekeys", method: "GET" },
    importRemoteKeys: { url: "/eth/v1/remotekeys", method: "POST" },
    deleteRemoteKeys: { url: "/eth/v1/remotekeys", method: "DELETE" },
    listFeeRecipient: { url: "/eth/v1/validator/{pubkey}/feerecipient", method: "GET" },
    setFeeRecipient: { url: "/eth/v1/validator/{pubkey}/feerecipient", method: "POST", statusOk: 202 },
    deleteFeeRecipient: { url: "/eth/v1/validator/{pubkey}/feerecipient", method: "DELETE", statusOk: 204 },
    listGraffiti: { url: "/eth/v1/validator/{pubkey}/graffiti", method: "GET" },
    setGraffiti: { url: "/eth/v1/validator/{pubkey}/graffiti", method: "POST", statusOk: 202 },
    deleteGraffiti: { url: "/eth/v1/validator/{pubkey}/graffiti", method: "DELETE", statusOk: 204 },
    getGasLimit: { url: "/eth/v1/validator/{pubkey}/gas_limit", method: "GET" },
    setGasLimit: { url: "/eth/v1/validator/{pubkey}/gas_limit", method: "POST", statusOk: 202 },
    deleteGasLimit: { url: "/eth/v1/validator/{pubkey}/gas_limit", method: "DELETE", statusOk: 204 },
    getBuilderBoostFactor: { url: "/eth/v1/validator/{pubkey}/builder_boost_factor", method: "GET" },
    setBuilderBoostFactor: { url: "/eth/v1/validator/{pubkey}/builder_boost_factor", method: "POST", statusOk: 202 },
    deleteBuilderBoostFactor: { url: "/eth/v1/validator/{pubkey}/builder_boost_factor", method: "DELETE", statusOk: 204 },
    signVoluntaryExit: { url: "/eth/v1/validator/{pubkey}/voluntary_exit", method: "POST" },
};
export function getReqSerializers() {
    return {
        listKeys: reqEmpty,
        importKeystores: {
            writeReq: (keystores, passwords, slashing_protection) => ({ body: { keystores, passwords, slashing_protection } }),
            parseReq: ({ body: { keystores, passwords, slashing_protection } }) => [keystores, passwords, slashing_protection],
            schema: { body: Schema.Object },
        },
        deleteKeys: {
            writeReq: (pubkeys) => ({ body: { pubkeys } }),
            parseReq: ({ body: { pubkeys } }) => [pubkeys],
            schema: { body: Schema.Object },
        },
        listRemoteKeys: reqEmpty,
        importRemoteKeys: {
            writeReq: (remote_keys) => ({ body: { remote_keys } }),
            parseReq: ({ body: { remote_keys } }) => [remote_keys],
            schema: { body: Schema.Object },
        },
        deleteRemoteKeys: {
            writeReq: (pubkeys) => ({ body: { pubkeys } }),
            parseReq: ({ body: { pubkeys } }) => [pubkeys],
            schema: { body: Schema.Object },
        },
        listFeeRecipient: {
            writeReq: (pubkey) => ({ params: { pubkey } }),
            parseReq: ({ params: { pubkey } }) => [pubkey],
            schema: {
                params: { pubkey: Schema.StringRequired },
            },
        },
        setFeeRecipient: {
            writeReq: (pubkey, ethaddress) => ({ params: { pubkey }, body: { ethaddress } }),
            parseReq: ({ params: { pubkey }, body: { ethaddress } }) => [pubkey, ethaddress],
            schema: {
                params: { pubkey: Schema.StringRequired },
                body: Schema.Object,
            },
        },
        deleteFeeRecipient: {
            writeReq: (pubkey) => ({ params: { pubkey } }),
            parseReq: ({ params: { pubkey } }) => [pubkey],
            schema: {
                params: { pubkey: Schema.StringRequired },
            },
        },
        listGraffiti: {
            writeReq: (pubkey) => ({ params: { pubkey } }),
            parseReq: ({ params: { pubkey } }) => [pubkey],
            schema: {
                params: { pubkey: Schema.StringRequired },
            },
        },
        setGraffiti: {
            writeReq: (pubkey, graffiti) => ({ params: { pubkey }, body: { graffiti } }),
            parseReq: ({ params: { pubkey }, body: { graffiti } }) => [pubkey, graffiti],
            schema: {
                params: { pubkey: Schema.StringRequired },
                body: Schema.Object,
            },
        },
        deleteGraffiti: {
            writeReq: (pubkey) => ({ params: { pubkey } }),
            parseReq: ({ params: { pubkey } }) => [pubkey],
            schema: {
                params: { pubkey: Schema.StringRequired },
            },
        },
        getGasLimit: {
            writeReq: (pubkey) => ({ params: { pubkey } }),
            parseReq: ({ params: { pubkey } }) => [pubkey],
            schema: {
                params: { pubkey: Schema.StringRequired },
            },
        },
        setGasLimit: {
            writeReq: (pubkey, gasLimit) => ({ params: { pubkey }, body: { gas_limit: gasLimit.toString(10) } }),
            parseReq: ({ params: { pubkey }, body: { gas_limit } }) => [pubkey, parseGasLimit(gas_limit)],
            schema: {
                params: { pubkey: Schema.StringRequired },
                body: Schema.Object,
            },
        },
        deleteGasLimit: {
            writeReq: (pubkey) => ({ params: { pubkey } }),
            parseReq: ({ params: { pubkey } }) => [pubkey],
            schema: {
                params: { pubkey: Schema.StringRequired },
            },
        },
        getBuilderBoostFactor: {
            writeReq: (pubkey) => ({ params: { pubkey } }),
            parseReq: ({ params: { pubkey } }) => [pubkey],
            schema: {
                params: { pubkey: Schema.StringRequired },
            },
        },
        setBuilderBoostFactor: {
            writeReq: (pubkey, builderBoostFactor) => ({
                params: { pubkey },
                body: { builder_boost_factor: builderBoostFactor.toString(10) },
            }),
            parseReq: ({ params: { pubkey }, body: { builder_boost_factor } }) => [pubkey, BigInt(builder_boost_factor)],
            schema: {
                params: { pubkey: Schema.StringRequired },
                body: Schema.Object,
            },
        },
        deleteBuilderBoostFactor: {
            writeReq: (pubkey) => ({ params: { pubkey } }),
            parseReq: ({ params: { pubkey } }) => [pubkey],
            schema: {
                params: { pubkey: Schema.StringRequired },
            },
        },
        signVoluntaryExit: {
            writeReq: (pubkey, epoch) => ({ params: { pubkey }, query: epoch !== undefined ? { epoch } : {} }),
            parseReq: ({ params: { pubkey }, query: { epoch } }) => [pubkey, epoch],
            schema: {
                params: { pubkey: Schema.StringRequired },
                query: { epoch: Schema.Uint },
            },
        },
    };
}
export function getReturnTypes() {
    return {
        listKeys: jsonType("snake"),
        importKeystores: jsonType("snake"),
        deleteKeys: jsonType("snake"),
        listRemoteKeys: jsonType("snake"),
        importRemoteKeys: jsonType("snake"),
        deleteRemoteKeys: jsonType("snake"),
        listFeeRecipient: jsonType("snake"),
        listGraffiti: jsonType("snake"),
        getGasLimit: ContainerData(new ContainerType({
            pubkey: stringType,
            gasLimit: ssz.UintNum64,
        }, { jsonCase: "eth2" })),
        getBuilderBoostFactor: ContainerData(new ContainerType({
            pubkey: stringType,
            builderBoostFactor: ssz.UintBn64,
        }, { jsonCase: "eth2" })),
        signVoluntaryExit: ContainerData(ssz.phase0.SignedVoluntaryExit),
    };
}
function parseGasLimit(gasLimitInput) {
    if ((typeof gasLimitInput !== "string" && typeof gasLimitInput !== "number") || `${gasLimitInput}`.trim() === "") {
        throw Error("Not valid Gas Limit");
    }
    const gasLimit = Number(gasLimitInput);
    if (Number.isNaN(gasLimit) || gasLimit === 0) {
        throw Error(`Gas Limit is not valid gasLimit=${gasLimit}`);
    }
    return gasLimit;
}
//# sourceMappingURL=routes.js.map