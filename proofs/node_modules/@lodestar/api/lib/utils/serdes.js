import { fromHexString, toHexString } from "@chainsafe/ssz";
/**
 * Serialize proof path to JSON.
 * @param paths `[["finalized_checkpoint", 0, "root", 12000]]`
 * @returns `['["finalized_checkpoint",0,"root",12000]']`
 */
export function querySerializeProofPathsArr(paths) {
    return paths.map((path) => JSON.stringify(path));
}
/**
 * Deserialize JSON proof path to proof path
 * @param pathStrs `['["finalized_checkpoint",0,"root",12000]']`
 * @returns `[["finalized_checkpoint", 0, "root", 12000]]`
 */
export function queryParseProofPathsArr(pathStrs) {
    if (Array.isArray(pathStrs)) {
        return pathStrs.map((pathStr) => queryParseProofPaths(pathStr));
    }
    else {
        return [queryParseProofPaths(pathStrs)];
    }
}
/**
 * Deserialize single JSON proof path to proof path
 * @param pathStr `'["finalized_checkpoint",0,"root",12000]'`
 * @returns `["finalized_checkpoint", 0, "root", 12000]`
 */
export function queryParseProofPaths(pathStr) {
    const path = JSON.parse(pathStr);
    if (!Array.isArray(path)) {
        throw Error("Proof pathStr is not an array");
    }
    for (let i = 0; i < path.length; i++) {
        const elType = typeof path[i];
        if (elType !== "string" && elType !== "number") {
            throw Error(`Proof pathStr[${i}] not string or number`);
        }
    }
    return path;
}
export function fromU64Str(u64Str) {
    const u64 = parseInt(u64Str, 10);
    if (!isFinite(u64)) {
        throw Error(`Invalid uin64 ${u64Str}`);
    }
    return u64;
}
export function toU64Str(u64) {
    return u64.toString(10);
}
export function fromU64StrOpt(u64Str) {
    return u64Str !== undefined ? fromU64Str(u64Str) : undefined;
}
export function toU64StrOpt(u64) {
    return u64 !== undefined ? toU64Str(u64) : undefined;
}
const GRAFFITI_HEX_LENGTH = 66;
export function toGraffitiHex(utf8) {
    const hex = toHexString(new TextEncoder().encode(utf8));
    if (hex.length > GRAFFITI_HEX_LENGTH) {
        // remove characters from the end if hex string is too long
        return hex.slice(0, GRAFFITI_HEX_LENGTH);
    }
    if (hex.length < GRAFFITI_HEX_LENGTH) {
        // right-pad with zeros if hex string is too short
        return hex.padEnd(GRAFFITI_HEX_LENGTH, "0");
    }
    return hex;
}
export function fromGraffitiHex(hex) {
    try {
        return new TextDecoder("utf8").decode(fromHexString(hex));
    }
    catch {
        // allow malformed graffiti hex string
        return hex;
    }
}
//# sourceMappingURL=serdes.js.map