import { TimeoutError, mapValues } from "@lodestar/utils";
import { compileRouteUrlFormater } from "../urlFormat.js";
import { HttpError } from "./httpClient.js";
import { HttpStatusCode } from "./httpStatusCode.js";
// See /packages/api/src/routes/index.ts for reasoning
/**
 * Format FetchFn opts from Fn arguments given a route definition and request serializer.
 * For routes that return only JSOn use @see getGenericJsonClient
 */
// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
export function getFetchOptsSerializer(routeDef, reqSerializer, routeId) {
    const urlFormater = compileRouteUrlFormater(routeDef.url);
    return function getFetchOpts(...args) {
        const req = reqSerializer.writeReq(...args);
        return {
            url: urlFormater(req.params ?? {}),
            method: routeDef.method,
            query: Object.keys(req.query ?? {}).length ? req.query : undefined,
            body: req.body,
            headers: req.headers,
            routeId,
        };
    };
}
/**
 * Generate `getFetchOptsSerializer()` functions for all routes in `Api`
 */
// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
export function getFetchOptsSerializers(routesData, reqSerializers) {
    return mapValues(routesData, (routeDef, routeId) => getFetchOptsSerializer(routeDef, reqSerializers[routeId], routeId));
}
/**
 * Get a generic JSON client from route definition, request serializer and return types.
 */
export function generateGenericJsonClient(routesData, reqSerializers, returnTypes, fetchFn) {
    return mapValues(routesData, (routeDef, routeId) => {
        const fetchOptsSerializer = getFetchOptsSerializer(routeDef, reqSerializers[routeId], routeId);
        const returnType = returnTypes[routeId];
        return async function request(...args) {
            try {
                // extract the extraOpts if provided
                //
                const argLen = args?.length ?? 0;
                const lastArg = args[argLen];
                const retries = lastArg?.retries;
                const extraOpts = { retries };
                if (returnType) {
                    // open extraOpts first if some serializer wants to add some overriding param
                    const res = await fetchFn.json({
                        ...extraOpts,
                        ...fetchOptsSerializer(...args),
                    });
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/return-await
                    return { ok: true, response: returnType.fromJson(res.body), status: res.status };
                }
                else {
                    // We need to avoid parsing the response as the servers might just
                    // response status 200 and close the request instead of writing an
                    // empty json response. We return the status code.
                    const res = await fetchFn.request({
                        ...extraOpts,
                        ...fetchOptsSerializer(...args),
                    });
                    // eslint-disable-next-line @typescript-eslint/return-await
                    return { ok: true, response: undefined, status: res.status };
                }
            }
            catch (err) {
                if (err instanceof HttpError) {
                    return {
                        ok: false,
                        status: err.status,
                        error: { code: err.status, message: err.message, operationId: routeId },
                    };
                }
                if (err instanceof TimeoutError) {
                    return {
                        ok: false,
                        status: HttpStatusCode.INTERNAL_SERVER_ERROR,
                        error: { code: HttpStatusCode.INTERNAL_SERVER_ERROR, message: err.message, operationId: routeId },
                    };
                }
                throw err;
            }
        };
    });
}
//# sourceMappingURL=client.js.map