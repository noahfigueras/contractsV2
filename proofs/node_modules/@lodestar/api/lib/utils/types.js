import { isBasicType, ListBasicType, isCompositeType, ListCompositeType } from "@chainsafe/ssz";
import { ForkName } from "@lodestar/params";
import { objectToExpectedCase } from "@lodestar/utils";
// See /packages/api/src/routes/index.ts for reasoning
/* eslint-disable @typescript-eslint/naming-convention, @typescript-eslint/no-explicit-any */
/** All JSON inside the JS code must be camel case */
const codeCase = "camel";
//
// Helpers
//
/** Shortcut for routes that have no params, query nor body */
export const reqEmpty = {
    writeReq: () => ({}),
    parseReq: () => [],
};
/** Shortcut for routes that have only body */
export const reqOnlyBody = (type, bodySchema) => ({
    writeReq: (items) => ({ body: type.toJson(items) }),
    parseReq: ({ body }) => [type.fromJson(body)],
    schema: { body: bodySchema },
});
/** SSZ factory helper + typed. limit = 1e6 as a big enough random number */
export function ArrayOf(elementType) {
    if (isCompositeType(elementType)) {
        return new ListCompositeType(elementType, Infinity);
    }
    else if (isBasicType(elementType)) {
        return new ListBasicType(elementType, Infinity);
    }
    else {
        throw Error(`Unknown type ${elementType.typeName}`);
    }
}
/**
 * SSZ factory helper + typed to return responses of type
 * ```
 * data: T
 * ```
 */
export function ContainerData(dataType) {
    return {
        toJson: ({ data }) => ({
            data: dataType.toJson(data),
        }),
        fromJson: ({ data }) => {
            return {
                data: dataType.fromJson(data),
            };
        },
    };
}
/**
 * SSZ factory helper + typed to return responses of type `{data: T; executionOptimistic: boolean}`
 */
export function ContainerDataExecutionOptimistic(dataType) {
    return {
        toJson: ({ data, executionOptimistic }) => ({
            data: dataType.toJson(data),
            execution_optimistic: executionOptimistic,
        }),
        fromJson: ({ data, execution_optimistic }) => {
            return {
                data: dataType.fromJson(data),
                executionOptimistic: execution_optimistic,
            };
        },
    };
}
/**
 * SSZ factory helper + typed to return responses of type
 * ```
 * data: T
 * version: ForkName
 * ```
 */
export function WithVersion(getType) {
    return {
        toJson: ({ data, version }) => ({
            data: getType(version ?? ForkName.phase0).toJson(data),
            version,
        }),
        fromJson: ({ data, version }) => {
            // Teku returns fork as UPPERCASE
            version = version.toLowerCase();
            // Un-safe external data, validate version is known ForkName value
            if (!(version in ForkName))
                throw Error(`Invalid version ${version}`);
            return {
                data: getType(version).fromJson(data),
                version: version,
            };
        },
    };
}
/**
 * SSZ factory helper to wrap an existing type with `{executionOptimistic: boolean}`
 */
export function WithExecutionOptimistic(type) {
    return {
        toJson: ({ executionOptimistic, ...data }) => ({
            ...type.toJson(data),
            execution_optimistic: executionOptimistic,
        }),
        fromJson: ({ execution_optimistic, ...data }) => ({
            ...type.fromJson(data),
            executionOptimistic: execution_optimistic,
        }),
    };
}
/**
 * SSZ factory helper to wrap an existing type with `{executionPayloadValue: Wei, consensusBlockValue: Wei}`
 */
export function WithBlockValues(type) {
    return {
        toJson: ({ executionPayloadValue, consensusBlockValue, ...data }) => ({
            ...type.toJson(data),
            execution_payload_value: executionPayloadValue.toString(),
            consensus_block_value: consensusBlockValue.toString(),
        }),
        fromJson: ({ execution_payload_value, consensus_block_value, ...data }) => ({
            ...type.fromJson(data),
            // For cross client usage where beacon or validator are of separate clients, executionPayloadValue could be missing
            executionPayloadValue: BigInt(execution_payload_value ?? "0"),
            consensusBlockValue: BigInt(consensus_block_value ?? "0"),
        }),
    };
}
/** Helper to only translate casing */
export function jsonType(jsonCase) {
    return {
        toJson: (val) => objectToExpectedCase(val, jsonCase),
        fromJson: (json) => objectToExpectedCase(json, codeCase),
    };
}
/** Helper to not do any transformation with the type */
export function sameType() {
    return {
        toJson: (val) => val,
        fromJson: (json) => json,
    };
}
//# sourceMappingURL=types.js.map