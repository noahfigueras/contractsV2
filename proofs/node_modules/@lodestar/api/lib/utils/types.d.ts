import { Type, ArrayType } from "@chainsafe/ssz";
import { ForkName } from "@lodestar/params";
import { ChainForkConfig } from "@lodestar/config";
import { APIClientHandler, ApiClientResponseData, APIServerHandler, ClientApi } from "../interfaces.js";
import { Schema, SchemaDefinition } from "./schema.js";
export type RouteGroupDefinition<Api extends Record<string, APIServerHandler>, ReqTypes extends {
    [K in keyof Api]: ReqGeneric;
}> = {
    routesData: RoutesData<Api>;
    getReqSerializers: (config: ChainForkConfig) => ReqSerializers<Api, ReqTypes>;
    getReturnTypes: (config: ChainForkConfig) => ReturnTypes<ClientApi<Api>>;
};
export type RouteDef = {
    url: string;
    method: "GET" | "POST" | "DELETE";
    statusOk?: number;
};
export type ReqGeneric = {
    params?: Record<string, string | number>;
    query?: Record<string, string | number | boolean | (string | number)[]>;
    body?: any;
    headers?: Record<string, string[] | string | undefined>;
};
export type ReqEmpty = ReqGeneric;
export type Resolves<T extends (...args: any) => any> = Awaited<ReturnType<T>>;
export type TypeJson<T> = {
    toJson(val: T): unknown;
    fromJson(json: unknown): T;
};
export type ReqSerializer<Fn extends (...args: any) => any, ReqType extends ReqGeneric> = {
    writeReq: (...args: Parameters<Fn>) => ReqType;
    parseReq: (arg: ReqType) => Parameters<Fn>;
    schema?: SchemaDefinition<ReqType>;
};
export type ReqSerializers<Api extends Record<string, APIServerHandler>, ReqTypes extends {
    [K in keyof Api]: ReqGeneric;
}> = {
    [K in keyof Api]: ReqSerializer<Api[K], ReqTypes[K]>;
};
/** Curried definition to infer only one of the two generic types */
export type ReqGenArg<Fn extends (...args: any) => any, ReqType extends ReqGeneric> = ReqSerializer<Fn, ReqType>;
/** Shortcut for routes that have no params, query nor body */
export declare const reqEmpty: ReqSerializer<() => void, ReqEmpty>;
/** Shortcut for routes that have only body */
export declare const reqOnlyBody: <T>(type: TypeJson<T>, bodySchema: Schema) => ReqGenArg<(arg: T) => Promise<void>, {
    body: unknown;
}>;
/** SSZ factory helper + typed. limit = 1e6 as a big enough random number */
export declare function ArrayOf<T>(elementType: Type<T>): ArrayType<Type<T>, unknown, unknown>;
/**
 * SSZ factory helper + typed to return responses of type
 * ```
 * data: T
 * ```
 */
export declare function ContainerData<T>(dataType: TypeJson<T>): TypeJson<{
    data: T;
}>;
/**
 * SSZ factory helper + typed to return responses of type `{data: T; executionOptimistic: boolean}`
 */
export declare function ContainerDataExecutionOptimistic<T>(dataType: TypeJson<T>): TypeJson<{
    data: T;
    executionOptimistic: boolean;
}>;
/**
 * SSZ factory helper + typed to return responses of type
 * ```
 * data: T
 * version: ForkName
 * ```
 */
export declare function WithVersion<T>(getType: (fork: ForkName) => TypeJson<T>): TypeJson<{
    data: T;
    version: ForkName;
}>;
/**
 * SSZ factory helper to wrap an existing type with `{executionOptimistic: boolean}`
 */
export declare function WithExecutionOptimistic<T extends {
    data: unknown;
}>(type: TypeJson<T>): TypeJson<T & {
    executionOptimistic: boolean;
}>;
/**
 * SSZ factory helper to wrap an existing type with `{executionPayloadValue: Wei, consensusBlockValue: Wei}`
 */
export declare function WithBlockValues<T extends {
    data: unknown;
}>(type: TypeJson<T>): TypeJson<T & {
    executionPayloadValue: bigint;
    consensusBlockValue: bigint;
}>;
type JsonCase = "snake" | "constant" | "camel" | "param" | "header" | "pascal" | "dot" | "notransform";
/** Helper to only translate casing */
export declare function jsonType<T extends Record<string, unknown> | Record<string, unknown>[] | unknown[]>(jsonCase: JsonCase): TypeJson<T>;
/** Helper to not do any transformation with the type */
export declare function sameType<T>(): TypeJson<T>;
export type KeysOfNonVoidResolveValues<Api extends Record<string, APIClientHandler>> = {
    [K in keyof Api]: ApiClientResponseData<Resolves<Api[K]>> extends void ? never : K;
}[keyof Api];
export type ReturnTypes<Api extends Record<string, APIClientHandler>> = {
    [K in keyof Pick<Api, KeysOfNonVoidResolveValues<Api>>]: TypeJson<ApiClientResponseData<Resolves<Api[K]>>>;
};
export type RoutesData<Api extends Record<string, APIServerHandler>> = {
    [K in keyof Api]: RouteDef;
};
export {};
//# sourceMappingURL=types.d.ts.map