import { allForks, bellatrix, Slot, Root, BLSPubkey } from "@lodestar/types";
import { ForkName } from "@lodestar/params";
import { ChainForkConfig } from "@lodestar/config";
import { ReturnTypes, RoutesData, ReqSerializers, ReqEmpty } from "../utils/index.js";
import { HttpStatusCode } from "../utils/client/httpStatusCode.js";
import { ApiClientResponse } from "../interfaces.js";
export type Api = {
    status(): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: void;
    }, HttpStatusCode.SERVICE_UNAVAILABLE>>;
    registerValidator(registrations: bellatrix.SignedValidatorRegistrationV1[]): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: void;
    }, HttpStatusCode.BAD_REQUEST>>;
    getHeader(slot: Slot, parentHash: Root, proposerPubKey: BLSPubkey): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: {
            data: allForks.SignedBuilderBid;
            version: ForkName;
        };
    }, HttpStatusCode.NOT_FOUND | HttpStatusCode.BAD_REQUEST>>;
    submitBlindedBlock(signedBlock: allForks.SignedBlindedBeaconBlock): Promise<ApiClientResponse<{
        [HttpStatusCode.OK]: {
            data: allForks.ExecutionPayload | allForks.ExecutionPayloadAndBlobsBundle;
            version: ForkName;
        };
    }, HttpStatusCode.SERVICE_UNAVAILABLE>>;
};
/**
 * Define javascript values for each route
 */
export declare const routesData: RoutesData<Api>;
export type ReqTypes = {
    status: ReqEmpty;
    registerValidator: {
        body: unknown;
    };
    getHeader: {
        params: {
            slot: Slot;
            parent_hash: string;
            pubkey: string;
        };
    };
    submitBlindedBlock: {
        body: unknown;
    };
};
export declare function getReqSerializers(config: ChainForkConfig): ReqSerializers<Api, ReqTypes>;
export declare function getReturnTypes(): ReturnTypes<Api>;
//# sourceMappingURL=routes.d.ts.map