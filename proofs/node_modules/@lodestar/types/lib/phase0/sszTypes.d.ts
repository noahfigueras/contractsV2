import { BitListType, BitVectorType, ContainerType, ContainerNodeStructType, ListBasicType, ListCompositeType, VectorBasicType, VectorCompositeType } from "@chainsafe/ssz";
export declare const AttestationSubnets: BitVectorType;
/** BeaconBlockHeader where slot is bounded by the clock, and values above it are invalid */
export declare const BeaconBlockHeader: ContainerType<{
    slot: import("@chainsafe/ssz").UintNumberType;
    proposerIndex: import("@chainsafe/ssz").UintNumberType;
    parentRoot: import("@chainsafe/ssz").ByteVectorType;
    stateRoot: import("@chainsafe/ssz").ByteVectorType;
    bodyRoot: import("@chainsafe/ssz").ByteVectorType;
}>;
/** BeaconBlockHeader where slot is NOT bounded by the clock, i.e. slashings. So slot is a bigint. */
export declare const BeaconBlockHeaderBigint: ContainerType<{
    slot: import("@chainsafe/ssz").UintBigintType;
    proposerIndex: import("@chainsafe/ssz").UintNumberType;
    parentRoot: import("@chainsafe/ssz").ByteVectorType;
    stateRoot: import("@chainsafe/ssz").ByteVectorType;
    bodyRoot: import("@chainsafe/ssz").ByteVectorType;
}>;
export declare const SignedBeaconBlockHeader: ContainerType<{
    message: ContainerType<{
        slot: import("@chainsafe/ssz").UintNumberType;
        proposerIndex: import("@chainsafe/ssz").UintNumberType;
        parentRoot: import("@chainsafe/ssz").ByteVectorType;
        stateRoot: import("@chainsafe/ssz").ByteVectorType;
        bodyRoot: import("@chainsafe/ssz").ByteVectorType;
    }>;
    signature: import("@chainsafe/ssz").ByteVectorType;
}>;
/** Same as `SignedBeaconBlockHeader` but slot is not bounded by the clock and must be a bigint */
export declare const SignedBeaconBlockHeaderBigint: ContainerType<{
    message: ContainerType<{
        slot: import("@chainsafe/ssz").UintBigintType;
        proposerIndex: import("@chainsafe/ssz").UintNumberType;
        parentRoot: import("@chainsafe/ssz").ByteVectorType;
        stateRoot: import("@chainsafe/ssz").ByteVectorType;
        bodyRoot: import("@chainsafe/ssz").ByteVectorType;
    }>;
    signature: import("@chainsafe/ssz").ByteVectorType;
}>;
/** Checkpoint where epoch is bounded by the clock, and values above it are invalid */
export declare const Checkpoint: ContainerType<{
    epoch: import("@chainsafe/ssz").UintNumberType;
    root: import("@chainsafe/ssz").ByteVectorType;
}>;
/** Checkpoint where epoch is NOT bounded by the clock, so must be a bigint */
export declare const CheckpointBigint: ContainerType<{
    epoch: import("@chainsafe/ssz").UintBigintType;
    root: import("@chainsafe/ssz").ByteVectorType;
}>;
export declare const CommitteeBits: BitListType;
export declare const CommitteeIndices: ListBasicType<import("@chainsafe/ssz").UintNumberType>;
export declare const DepositMessage: ContainerType<{
    pubkey: import("@chainsafe/ssz").ByteVectorType;
    withdrawalCredentials: import("@chainsafe/ssz").ByteVectorType;
    amount: import("@chainsafe/ssz").UintNumberType;
}>;
export declare const DepositData: ContainerType<{
    pubkey: import("@chainsafe/ssz").ByteVectorType;
    withdrawalCredentials: import("@chainsafe/ssz").ByteVectorType;
    amount: import("@chainsafe/ssz").UintNumberType;
    signature: import("@chainsafe/ssz").ByteVectorType;
}>;
export declare const DepositDataRootList: ListCompositeType<import("@chainsafe/ssz").ByteVectorType>;
export declare const DepositEvent: ContainerType<{
    depositData: ContainerType<{
        pubkey: import("@chainsafe/ssz").ByteVectorType;
        withdrawalCredentials: import("@chainsafe/ssz").ByteVectorType;
        amount: import("@chainsafe/ssz").UintNumberType;
        signature: import("@chainsafe/ssz").ByteVectorType;
    }>;
    blockNumber: import("@chainsafe/ssz").UintNumberType;
    index: import("@chainsafe/ssz").UintNumberType;
}>;
export declare const Eth1Data: ContainerType<{
    depositRoot: import("@chainsafe/ssz").ByteVectorType;
    depositCount: import("@chainsafe/ssz").UintNumberType;
    blockHash: import("@chainsafe/ssz").ByteVectorType;
}>;
export declare const Eth1DataVotes: ListCompositeType<ContainerType<{
    depositRoot: import("@chainsafe/ssz").ByteVectorType;
    depositCount: import("@chainsafe/ssz").UintNumberType;
    blockHash: import("@chainsafe/ssz").ByteVectorType;
}>>;
export declare const Eth1DataOrdered: ContainerType<{
    depositRoot: import("@chainsafe/ssz").ByteVectorType;
    depositCount: import("@chainsafe/ssz").UintNumberType;
    blockHash: import("@chainsafe/ssz").ByteVectorType;
    blockNumber: import("@chainsafe/ssz").UintNumberType;
}>;
/** Spec'ed but only used in lodestar as a type */
export declare const Eth1Block: ContainerType<{
    timestamp: import("@chainsafe/ssz").UintNumberType;
    depositRoot: import("@chainsafe/ssz").ByteVectorType;
    depositCount: import("@chainsafe/ssz").UintNumberType;
}>;
export declare const Fork: ContainerType<{
    previousVersion: import("@chainsafe/ssz").ByteVectorType;
    currentVersion: import("@chainsafe/ssz").ByteVectorType;
    epoch: import("@chainsafe/ssz").UintNumberType;
}>;
export declare const ForkData: ContainerType<{
    currentVersion: import("@chainsafe/ssz").ByteVectorType;
    genesisValidatorsRoot: import("@chainsafe/ssz").ByteVectorType;
}>;
export declare const ENRForkID: ContainerType<{
    forkDigest: import("@chainsafe/ssz").ByteVectorType;
    nextForkVersion: import("@chainsafe/ssz").ByteVectorType;
    nextForkEpoch: import("@chainsafe/ssz").UintNumberType;
}>;
export declare const HistoricalBlockRoots: VectorCompositeType<import("@chainsafe/ssz").ByteVectorType>;
export declare const HistoricalStateRoots: VectorCompositeType<import("@chainsafe/ssz").ByteVectorType>;
export declare const HistoricalBatch: ContainerType<{
    blockRoots: VectorCompositeType<import("@chainsafe/ssz").ByteVectorType>;
    stateRoots: VectorCompositeType<import("@chainsafe/ssz").ByteVectorType>;
}>;
/**
 * Non-spec'ed helper type to allow efficient hashing in epoch transition.
 * This type is like a 'Header' of HistoricalBatch where its fields are hashed.
 */
export declare const HistoricalBatchRoots: ContainerType<{
    blockRoots: import("@chainsafe/ssz").ByteVectorType;
    stateRoots: import("@chainsafe/ssz").ByteVectorType;
}>;
export declare const ValidatorContainer: ContainerType<{
    pubkey: import("@chainsafe/ssz").ByteVectorType;
    withdrawalCredentials: import("@chainsafe/ssz").ByteVectorType;
    effectiveBalance: import("@chainsafe/ssz").UintNumberType;
    slashed: import("@chainsafe/ssz").BooleanType;
    activationEligibilityEpoch: import("@chainsafe/ssz").UintNumberType;
    activationEpoch: import("@chainsafe/ssz").UintNumberType;
    exitEpoch: import("@chainsafe/ssz").UintNumberType;
    withdrawableEpoch: import("@chainsafe/ssz").UintNumberType;
}>;
export declare const ValidatorNodeStruct: ContainerNodeStructType<{
    pubkey: import("@chainsafe/ssz").ByteVectorType;
    withdrawalCredentials: import("@chainsafe/ssz").ByteVectorType;
    effectiveBalance: import("@chainsafe/ssz").UintNumberType;
    slashed: import("@chainsafe/ssz").BooleanType;
    activationEligibilityEpoch: import("@chainsafe/ssz").UintNumberType;
    activationEpoch: import("@chainsafe/ssz").UintNumberType;
    exitEpoch: import("@chainsafe/ssz").UintNumberType;
    withdrawableEpoch: import("@chainsafe/ssz").UintNumberType;
}>;
export declare const Validator: ContainerNodeStructType<{
    pubkey: import("@chainsafe/ssz").ByteVectorType;
    withdrawalCredentials: import("@chainsafe/ssz").ByteVectorType;
    effectiveBalance: import("@chainsafe/ssz").UintNumberType;
    slashed: import("@chainsafe/ssz").BooleanType;
    activationEligibilityEpoch: import("@chainsafe/ssz").UintNumberType;
    activationEpoch: import("@chainsafe/ssz").UintNumberType;
    exitEpoch: import("@chainsafe/ssz").UintNumberType;
    withdrawableEpoch: import("@chainsafe/ssz").UintNumberType;
}>;
export declare const Validators: ListCompositeType<ContainerNodeStructType<{
    pubkey: import("@chainsafe/ssz").ByteVectorType;
    withdrawalCredentials: import("@chainsafe/ssz").ByteVectorType;
    effectiveBalance: import("@chainsafe/ssz").UintNumberType;
    slashed: import("@chainsafe/ssz").BooleanType;
    activationEligibilityEpoch: import("@chainsafe/ssz").UintNumberType;
    activationEpoch: import("@chainsafe/ssz").UintNumberType;
    exitEpoch: import("@chainsafe/ssz").UintNumberType;
    withdrawableEpoch: import("@chainsafe/ssz").UintNumberType;
}>>;
export declare const Balances: ListBasicType<import("@chainsafe/ssz").UintNumberType>;
export declare const RandaoMixes: VectorCompositeType<import("@chainsafe/ssz").ByteVectorType>;
/**
 * This is initially a Gwei (BigInt) vector, however since Nov 2023 it's converted to UintNum64 (number) vector in the state transition because:
 * - state.slashings[nextEpoch % EPOCHS_PER_SLASHINGS_VECTOR] is reset per epoch in processSlashingsReset()
 * - max slashed validators per epoch is SLOTS_PER_EPOCH * MAX_ATTESTER_SLASHINGS * MAX_VALIDATORS_PER_COMMITTEE which is 32 * 2 * 2048 = 131072 on mainnet
 * - with that and 32_000_000_000 MAX_EFFECTIVE_BALANCE, it still fits in a number given that Math.floor(Number.MAX_SAFE_INTEGER / 32_000_000_000) = 281474
 * - we don't need to compute the total slashings from state.slashings, it's handled by totalSlashingsByIncrement in EpochCache
 */
export declare const Slashings: VectorBasicType<import("@chainsafe/ssz").UintNumberType>;
export declare const JustificationBits: BitVectorType;
export declare const AttestationData: ContainerType<{
    slot: import("@chainsafe/ssz").UintNumberType;
    index: import("@chainsafe/ssz").UintNumberType;
    beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
    source: ContainerType<{
        epoch: import("@chainsafe/ssz").UintNumberType;
        root: import("@chainsafe/ssz").ByteVectorType;
    }>;
    target: ContainerType<{
        epoch: import("@chainsafe/ssz").UintNumberType;
        root: import("@chainsafe/ssz").ByteVectorType;
    }>;
}>;
/** Same as `AttestationData` but epoch, slot and index are not bounded and must be a bigint */
export declare const AttestationDataBigint: ContainerType<{
    slot: import("@chainsafe/ssz").UintBigintType;
    index: import("@chainsafe/ssz").UintBigintType;
    beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
    source: ContainerType<{
        epoch: import("@chainsafe/ssz").UintBigintType;
        root: import("@chainsafe/ssz").ByteVectorType;
    }>;
    target: ContainerType<{
        epoch: import("@chainsafe/ssz").UintBigintType;
        root: import("@chainsafe/ssz").ByteVectorType;
    }>;
}>;
export declare const IndexedAttestation: ContainerType<{
    attestingIndices: ListBasicType<import("@chainsafe/ssz").UintNumberType>;
    data: ContainerType<{
        slot: import("@chainsafe/ssz").UintNumberType;
        index: import("@chainsafe/ssz").UintNumberType;
        beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
        source: ContainerType<{
            epoch: import("@chainsafe/ssz").UintNumberType;
            root: import("@chainsafe/ssz").ByteVectorType;
        }>;
        target: ContainerType<{
            epoch: import("@chainsafe/ssz").UintNumberType;
            root: import("@chainsafe/ssz").ByteVectorType;
        }>;
    }>;
    signature: import("@chainsafe/ssz").ByteVectorType;
}>;
/** Same as `IndexedAttestation` but epoch, slot and index are not bounded and must be a bigint */
export declare const IndexedAttestationBigint: ContainerType<{
    attestingIndices: ListBasicType<import("@chainsafe/ssz").UintNumberType>;
    data: ContainerType<{
        slot: import("@chainsafe/ssz").UintBigintType;
        index: import("@chainsafe/ssz").UintBigintType;
        beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
        source: ContainerType<{
            epoch: import("@chainsafe/ssz").UintBigintType;
            root: import("@chainsafe/ssz").ByteVectorType;
        }>;
        target: ContainerType<{
            epoch: import("@chainsafe/ssz").UintBigintType;
            root: import("@chainsafe/ssz").ByteVectorType;
        }>;
    }>;
    signature: import("@chainsafe/ssz").ByteVectorType;
}>;
export declare const PendingAttestation: ContainerType<{
    aggregationBits: BitListType;
    data: ContainerType<{
        slot: import("@chainsafe/ssz").UintNumberType;
        index: import("@chainsafe/ssz").UintNumberType;
        beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
        source: ContainerType<{
            epoch: import("@chainsafe/ssz").UintNumberType;
            root: import("@chainsafe/ssz").ByteVectorType;
        }>;
        target: ContainerType<{
            epoch: import("@chainsafe/ssz").UintNumberType;
            root: import("@chainsafe/ssz").ByteVectorType;
        }>;
    }>;
    inclusionDelay: import("@chainsafe/ssz").UintNumberType;
    proposerIndex: import("@chainsafe/ssz").UintNumberType;
}>;
export declare const SigningData: ContainerType<{
    objectRoot: import("@chainsafe/ssz").ByteVectorType;
    domain: import("@chainsafe/ssz").ByteVectorType;
}>;
export declare const Attestation: ContainerType<{
    aggregationBits: BitListType;
    data: ContainerType<{
        slot: import("@chainsafe/ssz").UintNumberType;
        index: import("@chainsafe/ssz").UintNumberType;
        beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
        source: ContainerType<{
            epoch: import("@chainsafe/ssz").UintNumberType;
            root: import("@chainsafe/ssz").ByteVectorType;
        }>;
        target: ContainerType<{
            epoch: import("@chainsafe/ssz").UintNumberType;
            root: import("@chainsafe/ssz").ByteVectorType;
        }>;
    }>;
    signature: import("@chainsafe/ssz").ByteVectorType;
}>;
export declare const AttesterSlashing: ContainerType<{
    attestation1: ContainerType<{
        attestingIndices: ListBasicType<import("@chainsafe/ssz").UintNumberType>;
        data: ContainerType<{
            slot: import("@chainsafe/ssz").UintBigintType;
            index: import("@chainsafe/ssz").UintBigintType;
            beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
            source: ContainerType<{
                epoch: import("@chainsafe/ssz").UintBigintType;
                root: import("@chainsafe/ssz").ByteVectorType;
            }>;
            target: ContainerType<{
                epoch: import("@chainsafe/ssz").UintBigintType;
                root: import("@chainsafe/ssz").ByteVectorType;
            }>;
        }>;
        signature: import("@chainsafe/ssz").ByteVectorType;
    }>;
    attestation2: ContainerType<{
        attestingIndices: ListBasicType<import("@chainsafe/ssz").UintNumberType>;
        data: ContainerType<{
            slot: import("@chainsafe/ssz").UintBigintType;
            index: import("@chainsafe/ssz").UintBigintType;
            beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
            source: ContainerType<{
                epoch: import("@chainsafe/ssz").UintBigintType;
                root: import("@chainsafe/ssz").ByteVectorType;
            }>;
            target: ContainerType<{
                epoch: import("@chainsafe/ssz").UintBigintType;
                root: import("@chainsafe/ssz").ByteVectorType;
            }>;
        }>;
        signature: import("@chainsafe/ssz").ByteVectorType;
    }>;
}>;
export declare const Deposit: ContainerType<{
    proof: VectorCompositeType<import("@chainsafe/ssz").ByteVectorType>;
    data: ContainerType<{
        pubkey: import("@chainsafe/ssz").ByteVectorType;
        withdrawalCredentials: import("@chainsafe/ssz").ByteVectorType;
        amount: import("@chainsafe/ssz").UintNumberType;
        signature: import("@chainsafe/ssz").ByteVectorType;
    }>;
}>;
export declare const ProposerSlashing: ContainerType<{
    signedHeader1: ContainerType<{
        message: ContainerType<{
            slot: import("@chainsafe/ssz").UintBigintType;
            proposerIndex: import("@chainsafe/ssz").UintNumberType;
            parentRoot: import("@chainsafe/ssz").ByteVectorType;
            stateRoot: import("@chainsafe/ssz").ByteVectorType;
            bodyRoot: import("@chainsafe/ssz").ByteVectorType;
        }>;
        signature: import("@chainsafe/ssz").ByteVectorType;
    }>;
    signedHeader2: ContainerType<{
        message: ContainerType<{
            slot: import("@chainsafe/ssz").UintBigintType;
            proposerIndex: import("@chainsafe/ssz").UintNumberType;
            parentRoot: import("@chainsafe/ssz").ByteVectorType;
            stateRoot: import("@chainsafe/ssz").ByteVectorType;
            bodyRoot: import("@chainsafe/ssz").ByteVectorType;
        }>;
        signature: import("@chainsafe/ssz").ByteVectorType;
    }>;
}>;
export declare const VoluntaryExit: ContainerType<{
    epoch: import("@chainsafe/ssz").UintNumberType;
    validatorIndex: import("@chainsafe/ssz").UintNumberType;
}>;
export declare const SignedVoluntaryExit: ContainerType<{
    message: ContainerType<{
        epoch: import("@chainsafe/ssz").UintNumberType;
        validatorIndex: import("@chainsafe/ssz").UintNumberType;
    }>;
    signature: import("@chainsafe/ssz").ByteVectorType;
}>;
export declare const BeaconBlockBody: ContainerType<{
    randaoReveal: import("@chainsafe/ssz").ByteVectorType;
    eth1Data: ContainerType<{
        depositRoot: import("@chainsafe/ssz").ByteVectorType;
        depositCount: import("@chainsafe/ssz").UintNumberType;
        blockHash: import("@chainsafe/ssz").ByteVectorType;
    }>;
    graffiti: import("@chainsafe/ssz").ByteVectorType;
    proposerSlashings: ListCompositeType<ContainerType<{
        signedHeader1: ContainerType<{
            message: ContainerType<{
                slot: import("@chainsafe/ssz").UintBigintType;
                proposerIndex: import("@chainsafe/ssz").UintNumberType;
                parentRoot: import("@chainsafe/ssz").ByteVectorType;
                stateRoot: import("@chainsafe/ssz").ByteVectorType;
                bodyRoot: import("@chainsafe/ssz").ByteVectorType;
            }>;
            signature: import("@chainsafe/ssz").ByteVectorType;
        }>;
        signedHeader2: ContainerType<{
            message: ContainerType<{
                slot: import("@chainsafe/ssz").UintBigintType;
                proposerIndex: import("@chainsafe/ssz").UintNumberType;
                parentRoot: import("@chainsafe/ssz").ByteVectorType;
                stateRoot: import("@chainsafe/ssz").ByteVectorType;
                bodyRoot: import("@chainsafe/ssz").ByteVectorType;
            }>;
            signature: import("@chainsafe/ssz").ByteVectorType;
        }>;
    }>>;
    attesterSlashings: ListCompositeType<ContainerType<{
        attestation1: ContainerType<{
            attestingIndices: ListBasicType<import("@chainsafe/ssz").UintNumberType>;
            data: ContainerType<{
                slot: import("@chainsafe/ssz").UintBigintType;
                index: import("@chainsafe/ssz").UintBigintType;
                beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
                source: ContainerType<{
                    epoch: import("@chainsafe/ssz").UintBigintType;
                    root: import("@chainsafe/ssz").ByteVectorType;
                }>;
                target: ContainerType<{
                    epoch: import("@chainsafe/ssz").UintBigintType;
                    root: import("@chainsafe/ssz").ByteVectorType;
                }>;
            }>;
            signature: import("@chainsafe/ssz").ByteVectorType;
        }>;
        attestation2: ContainerType<{
            attestingIndices: ListBasicType<import("@chainsafe/ssz").UintNumberType>;
            data: ContainerType<{
                slot: import("@chainsafe/ssz").UintBigintType;
                index: import("@chainsafe/ssz").UintBigintType;
                beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
                source: ContainerType<{
                    epoch: import("@chainsafe/ssz").UintBigintType;
                    root: import("@chainsafe/ssz").ByteVectorType;
                }>;
                target: ContainerType<{
                    epoch: import("@chainsafe/ssz").UintBigintType;
                    root: import("@chainsafe/ssz").ByteVectorType;
                }>;
            }>;
            signature: import("@chainsafe/ssz").ByteVectorType;
        }>;
    }>>;
    attestations: ListCompositeType<ContainerType<{
        aggregationBits: BitListType;
        data: ContainerType<{
            slot: import("@chainsafe/ssz").UintNumberType;
            index: import("@chainsafe/ssz").UintNumberType;
            beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
            source: ContainerType<{
                epoch: import("@chainsafe/ssz").UintNumberType;
                root: import("@chainsafe/ssz").ByteVectorType;
            }>;
            target: ContainerType<{
                epoch: import("@chainsafe/ssz").UintNumberType;
                root: import("@chainsafe/ssz").ByteVectorType;
            }>;
        }>;
        signature: import("@chainsafe/ssz").ByteVectorType;
    }>>;
    deposits: ListCompositeType<ContainerType<{
        proof: VectorCompositeType<import("@chainsafe/ssz").ByteVectorType>;
        data: ContainerType<{
            pubkey: import("@chainsafe/ssz").ByteVectorType;
            withdrawalCredentials: import("@chainsafe/ssz").ByteVectorType;
            amount: import("@chainsafe/ssz").UintNumberType;
            signature: import("@chainsafe/ssz").ByteVectorType;
        }>;
    }>>;
    voluntaryExits: ListCompositeType<ContainerType<{
        message: ContainerType<{
            epoch: import("@chainsafe/ssz").UintNumberType;
            validatorIndex: import("@chainsafe/ssz").UintNumberType;
        }>;
        signature: import("@chainsafe/ssz").ByteVectorType;
    }>>;
}>;
export declare const BeaconBlock: ContainerType<{
    slot: import("@chainsafe/ssz").UintNumberType;
    proposerIndex: import("@chainsafe/ssz").UintNumberType;
    parentRoot: import("@chainsafe/ssz").ByteVectorType;
    stateRoot: import("@chainsafe/ssz").ByteVectorType;
    body: ContainerType<{
        randaoReveal: import("@chainsafe/ssz").ByteVectorType;
        eth1Data: ContainerType<{
            depositRoot: import("@chainsafe/ssz").ByteVectorType;
            depositCount: import("@chainsafe/ssz").UintNumberType;
            blockHash: import("@chainsafe/ssz").ByteVectorType;
        }>;
        graffiti: import("@chainsafe/ssz").ByteVectorType;
        proposerSlashings: ListCompositeType<ContainerType<{
            signedHeader1: ContainerType<{
                message: ContainerType<{
                    slot: import("@chainsafe/ssz").UintBigintType;
                    proposerIndex: import("@chainsafe/ssz").UintNumberType;
                    parentRoot: import("@chainsafe/ssz").ByteVectorType;
                    stateRoot: import("@chainsafe/ssz").ByteVectorType;
                    bodyRoot: import("@chainsafe/ssz").ByteVectorType;
                }>;
                signature: import("@chainsafe/ssz").ByteVectorType;
            }>;
            signedHeader2: ContainerType<{
                message: ContainerType<{
                    slot: import("@chainsafe/ssz").UintBigintType;
                    proposerIndex: import("@chainsafe/ssz").UintNumberType;
                    parentRoot: import("@chainsafe/ssz").ByteVectorType;
                    stateRoot: import("@chainsafe/ssz").ByteVectorType;
                    bodyRoot: import("@chainsafe/ssz").ByteVectorType;
                }>;
                signature: import("@chainsafe/ssz").ByteVectorType;
            }>;
        }>>;
        attesterSlashings: ListCompositeType<ContainerType<{
            attestation1: ContainerType<{
                attestingIndices: ListBasicType<import("@chainsafe/ssz").UintNumberType>;
                data: ContainerType<{
                    slot: import("@chainsafe/ssz").UintBigintType;
                    index: import("@chainsafe/ssz").UintBigintType;
                    beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
                    source: ContainerType<{
                        epoch: import("@chainsafe/ssz").UintBigintType;
                        root: import("@chainsafe/ssz").ByteVectorType;
                    }>;
                    target: ContainerType<{
                        epoch: import("@chainsafe/ssz").UintBigintType;
                        root: import("@chainsafe/ssz").ByteVectorType;
                    }>;
                }>;
                signature: import("@chainsafe/ssz").ByteVectorType;
            }>;
            attestation2: ContainerType<{
                attestingIndices: ListBasicType<import("@chainsafe/ssz").UintNumberType>;
                data: ContainerType<{
                    slot: import("@chainsafe/ssz").UintBigintType;
                    index: import("@chainsafe/ssz").UintBigintType;
                    beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
                    source: ContainerType<{
                        epoch: import("@chainsafe/ssz").UintBigintType;
                        root: import("@chainsafe/ssz").ByteVectorType;
                    }>;
                    target: ContainerType<{
                        epoch: import("@chainsafe/ssz").UintBigintType;
                        root: import("@chainsafe/ssz").ByteVectorType;
                    }>;
                }>;
                signature: import("@chainsafe/ssz").ByteVectorType;
            }>;
        }>>;
        attestations: ListCompositeType<ContainerType<{
            aggregationBits: BitListType;
            data: ContainerType<{
                slot: import("@chainsafe/ssz").UintNumberType;
                index: import("@chainsafe/ssz").UintNumberType;
                beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
                source: ContainerType<{
                    epoch: import("@chainsafe/ssz").UintNumberType;
                    root: import("@chainsafe/ssz").ByteVectorType;
                }>;
                target: ContainerType<{
                    epoch: import("@chainsafe/ssz").UintNumberType;
                    root: import("@chainsafe/ssz").ByteVectorType;
                }>;
            }>;
            signature: import("@chainsafe/ssz").ByteVectorType;
        }>>;
        deposits: ListCompositeType<ContainerType<{
            proof: VectorCompositeType<import("@chainsafe/ssz").ByteVectorType>;
            data: ContainerType<{
                pubkey: import("@chainsafe/ssz").ByteVectorType;
                withdrawalCredentials: import("@chainsafe/ssz").ByteVectorType;
                amount: import("@chainsafe/ssz").UintNumberType;
                signature: import("@chainsafe/ssz").ByteVectorType;
            }>;
        }>>;
        voluntaryExits: ListCompositeType<ContainerType<{
            message: ContainerType<{
                epoch: import("@chainsafe/ssz").UintNumberType;
                validatorIndex: import("@chainsafe/ssz").UintNumberType;
            }>;
            signature: import("@chainsafe/ssz").ByteVectorType;
        }>>;
    }>;
}>;
export declare const SignedBeaconBlock: ContainerType<{
    message: ContainerType<{
        slot: import("@chainsafe/ssz").UintNumberType;
        proposerIndex: import("@chainsafe/ssz").UintNumberType;
        parentRoot: import("@chainsafe/ssz").ByteVectorType;
        stateRoot: import("@chainsafe/ssz").ByteVectorType;
        body: ContainerType<{
            randaoReveal: import("@chainsafe/ssz").ByteVectorType;
            eth1Data: ContainerType<{
                depositRoot: import("@chainsafe/ssz").ByteVectorType;
                depositCount: import("@chainsafe/ssz").UintNumberType;
                blockHash: import("@chainsafe/ssz").ByteVectorType;
            }>;
            graffiti: import("@chainsafe/ssz").ByteVectorType;
            proposerSlashings: ListCompositeType<ContainerType<{
                signedHeader1: ContainerType<{
                    message: ContainerType<{
                        slot: import("@chainsafe/ssz").UintBigintType;
                        proposerIndex: import("@chainsafe/ssz").UintNumberType;
                        parentRoot: import("@chainsafe/ssz").ByteVectorType;
                        stateRoot: import("@chainsafe/ssz").ByteVectorType;
                        bodyRoot: import("@chainsafe/ssz").ByteVectorType;
                    }>;
                    signature: import("@chainsafe/ssz").ByteVectorType;
                }>;
                signedHeader2: ContainerType<{
                    message: ContainerType<{
                        slot: import("@chainsafe/ssz").UintBigintType;
                        proposerIndex: import("@chainsafe/ssz").UintNumberType;
                        parentRoot: import("@chainsafe/ssz").ByteVectorType;
                        stateRoot: import("@chainsafe/ssz").ByteVectorType;
                        bodyRoot: import("@chainsafe/ssz").ByteVectorType;
                    }>;
                    signature: import("@chainsafe/ssz").ByteVectorType;
                }>;
            }>>;
            attesterSlashings: ListCompositeType<ContainerType<{
                attestation1: ContainerType<{
                    attestingIndices: ListBasicType<import("@chainsafe/ssz").UintNumberType>;
                    data: ContainerType<{
                        slot: import("@chainsafe/ssz").UintBigintType;
                        index: import("@chainsafe/ssz").UintBigintType;
                        beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
                        source: ContainerType<{
                            epoch: import("@chainsafe/ssz").UintBigintType;
                            root: import("@chainsafe/ssz").ByteVectorType;
                        }>;
                        target: ContainerType<{
                            epoch: import("@chainsafe/ssz").UintBigintType;
                            root: import("@chainsafe/ssz").ByteVectorType;
                        }>;
                    }>;
                    signature: import("@chainsafe/ssz").ByteVectorType;
                }>;
                attestation2: ContainerType<{
                    attestingIndices: ListBasicType<import("@chainsafe/ssz").UintNumberType>;
                    data: ContainerType<{
                        slot: import("@chainsafe/ssz").UintBigintType;
                        index: import("@chainsafe/ssz").UintBigintType;
                        beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
                        source: ContainerType<{
                            epoch: import("@chainsafe/ssz").UintBigintType;
                            root: import("@chainsafe/ssz").ByteVectorType;
                        }>;
                        target: ContainerType<{
                            epoch: import("@chainsafe/ssz").UintBigintType;
                            root: import("@chainsafe/ssz").ByteVectorType;
                        }>;
                    }>;
                    signature: import("@chainsafe/ssz").ByteVectorType;
                }>;
            }>>;
            attestations: ListCompositeType<ContainerType<{
                aggregationBits: BitListType;
                data: ContainerType<{
                    slot: import("@chainsafe/ssz").UintNumberType;
                    index: import("@chainsafe/ssz").UintNumberType;
                    beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
                    source: ContainerType<{
                        epoch: import("@chainsafe/ssz").UintNumberType;
                        root: import("@chainsafe/ssz").ByteVectorType;
                    }>;
                    target: ContainerType<{
                        epoch: import("@chainsafe/ssz").UintNumberType;
                        root: import("@chainsafe/ssz").ByteVectorType;
                    }>;
                }>;
                signature: import("@chainsafe/ssz").ByteVectorType;
            }>>;
            deposits: ListCompositeType<ContainerType<{
                proof: VectorCompositeType<import("@chainsafe/ssz").ByteVectorType>;
                data: ContainerType<{
                    pubkey: import("@chainsafe/ssz").ByteVectorType;
                    withdrawalCredentials: import("@chainsafe/ssz").ByteVectorType;
                    amount: import("@chainsafe/ssz").UintNumberType;
                    signature: import("@chainsafe/ssz").ByteVectorType;
                }>;
            }>>;
            voluntaryExits: ListCompositeType<ContainerType<{
                message: ContainerType<{
                    epoch: import("@chainsafe/ssz").UintNumberType;
                    validatorIndex: import("@chainsafe/ssz").UintNumberType;
                }>;
                signature: import("@chainsafe/ssz").ByteVectorType;
            }>>;
        }>;
    }>;
    signature: import("@chainsafe/ssz").ByteVectorType;
}>;
export declare const EpochAttestations: ListCompositeType<ContainerType<{
    aggregationBits: BitListType;
    data: ContainerType<{
        slot: import("@chainsafe/ssz").UintNumberType;
        index: import("@chainsafe/ssz").UintNumberType;
        beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
        source: ContainerType<{
            epoch: import("@chainsafe/ssz").UintNumberType;
            root: import("@chainsafe/ssz").ByteVectorType;
        }>;
        target: ContainerType<{
            epoch: import("@chainsafe/ssz").UintNumberType;
            root: import("@chainsafe/ssz").ByteVectorType;
        }>;
    }>;
    inclusionDelay: import("@chainsafe/ssz").UintNumberType;
    proposerIndex: import("@chainsafe/ssz").UintNumberType;
}>>;
export declare const BeaconState: ContainerType<{
    genesisTime: import("@chainsafe/ssz").UintNumberType;
    genesisValidatorsRoot: import("@chainsafe/ssz").ByteVectorType;
    slot: import("@chainsafe/ssz").UintNumberType;
    fork: ContainerType<{
        previousVersion: import("@chainsafe/ssz").ByteVectorType;
        currentVersion: import("@chainsafe/ssz").ByteVectorType;
        epoch: import("@chainsafe/ssz").UintNumberType;
    }>;
    latestBlockHeader: ContainerType<{
        slot: import("@chainsafe/ssz").UintNumberType;
        proposerIndex: import("@chainsafe/ssz").UintNumberType;
        parentRoot: import("@chainsafe/ssz").ByteVectorType;
        stateRoot: import("@chainsafe/ssz").ByteVectorType;
        bodyRoot: import("@chainsafe/ssz").ByteVectorType;
    }>;
    blockRoots: VectorCompositeType<import("@chainsafe/ssz").ByteVectorType>;
    stateRoots: VectorCompositeType<import("@chainsafe/ssz").ByteVectorType>;
    historicalRoots: ListCompositeType<import("@chainsafe/ssz").ByteVectorType>;
    eth1Data: ContainerType<{
        depositRoot: import("@chainsafe/ssz").ByteVectorType;
        depositCount: import("@chainsafe/ssz").UintNumberType;
        blockHash: import("@chainsafe/ssz").ByteVectorType;
    }>;
    eth1DataVotes: ListCompositeType<ContainerType<{
        depositRoot: import("@chainsafe/ssz").ByteVectorType;
        depositCount: import("@chainsafe/ssz").UintNumberType;
        blockHash: import("@chainsafe/ssz").ByteVectorType;
    }>>;
    eth1DepositIndex: import("@chainsafe/ssz").UintNumberType;
    validators: ListCompositeType<ContainerNodeStructType<{
        pubkey: import("@chainsafe/ssz").ByteVectorType;
        withdrawalCredentials: import("@chainsafe/ssz").ByteVectorType;
        effectiveBalance: import("@chainsafe/ssz").UintNumberType;
        slashed: import("@chainsafe/ssz").BooleanType;
        activationEligibilityEpoch: import("@chainsafe/ssz").UintNumberType;
        activationEpoch: import("@chainsafe/ssz").UintNumberType;
        exitEpoch: import("@chainsafe/ssz").UintNumberType;
        withdrawableEpoch: import("@chainsafe/ssz").UintNumberType;
    }>>;
    balances: ListBasicType<import("@chainsafe/ssz").UintNumberType>;
    randaoMixes: VectorCompositeType<import("@chainsafe/ssz").ByteVectorType>;
    slashings: VectorBasicType<import("@chainsafe/ssz").UintNumberType>;
    previousEpochAttestations: ListCompositeType<ContainerType<{
        aggregationBits: BitListType;
        data: ContainerType<{
            slot: import("@chainsafe/ssz").UintNumberType;
            index: import("@chainsafe/ssz").UintNumberType;
            beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
            source: ContainerType<{
                epoch: import("@chainsafe/ssz").UintNumberType;
                root: import("@chainsafe/ssz").ByteVectorType;
            }>;
            target: ContainerType<{
                epoch: import("@chainsafe/ssz").UintNumberType;
                root: import("@chainsafe/ssz").ByteVectorType;
            }>;
        }>;
        inclusionDelay: import("@chainsafe/ssz").UintNumberType;
        proposerIndex: import("@chainsafe/ssz").UintNumberType;
    }>>;
    currentEpochAttestations: ListCompositeType<ContainerType<{
        aggregationBits: BitListType;
        data: ContainerType<{
            slot: import("@chainsafe/ssz").UintNumberType;
            index: import("@chainsafe/ssz").UintNumberType;
            beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
            source: ContainerType<{
                epoch: import("@chainsafe/ssz").UintNumberType;
                root: import("@chainsafe/ssz").ByteVectorType;
            }>;
            target: ContainerType<{
                epoch: import("@chainsafe/ssz").UintNumberType;
                root: import("@chainsafe/ssz").ByteVectorType;
            }>;
        }>;
        inclusionDelay: import("@chainsafe/ssz").UintNumberType;
        proposerIndex: import("@chainsafe/ssz").UintNumberType;
    }>>;
    justificationBits: BitVectorType;
    previousJustifiedCheckpoint: ContainerType<{
        epoch: import("@chainsafe/ssz").UintNumberType;
        root: import("@chainsafe/ssz").ByteVectorType;
    }>;
    currentJustifiedCheckpoint: ContainerType<{
        epoch: import("@chainsafe/ssz").UintNumberType;
        root: import("@chainsafe/ssz").ByteVectorType;
    }>;
    finalizedCheckpoint: ContainerType<{
        epoch: import("@chainsafe/ssz").UintNumberType;
        root: import("@chainsafe/ssz").ByteVectorType;
    }>;
}>;
export declare const CommitteeAssignment: ContainerType<{
    validators: ListBasicType<import("@chainsafe/ssz").UintNumberType>;
    committeeIndex: import("@chainsafe/ssz").UintNumberType;
    slot: import("@chainsafe/ssz").UintNumberType;
}>;
export declare const AggregateAndProof: ContainerType<{
    aggregatorIndex: import("@chainsafe/ssz").UintNumberType;
    aggregate: ContainerType<{
        aggregationBits: BitListType;
        data: ContainerType<{
            slot: import("@chainsafe/ssz").UintNumberType;
            index: import("@chainsafe/ssz").UintNumberType;
            beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
            source: ContainerType<{
                epoch: import("@chainsafe/ssz").UintNumberType;
                root: import("@chainsafe/ssz").ByteVectorType;
            }>;
            target: ContainerType<{
                epoch: import("@chainsafe/ssz").UintNumberType;
                root: import("@chainsafe/ssz").ByteVectorType;
            }>;
        }>;
        signature: import("@chainsafe/ssz").ByteVectorType;
    }>;
    selectionProof: import("@chainsafe/ssz").ByteVectorType;
}>;
export declare const SignedAggregateAndProof: ContainerType<{
    message: ContainerType<{
        aggregatorIndex: import("@chainsafe/ssz").UintNumberType;
        aggregate: ContainerType<{
            aggregationBits: BitListType;
            data: ContainerType<{
                slot: import("@chainsafe/ssz").UintNumberType;
                index: import("@chainsafe/ssz").UintNumberType;
                beaconBlockRoot: import("@chainsafe/ssz").ByteVectorType;
                source: ContainerType<{
                    epoch: import("@chainsafe/ssz").UintNumberType;
                    root: import("@chainsafe/ssz").ByteVectorType;
                }>;
                target: ContainerType<{
                    epoch: import("@chainsafe/ssz").UintNumberType;
                    root: import("@chainsafe/ssz").ByteVectorType;
                }>;
            }>;
            signature: import("@chainsafe/ssz").ByteVectorType;
        }>;
        selectionProof: import("@chainsafe/ssz").ByteVectorType;
    }>;
    signature: import("@chainsafe/ssz").ByteVectorType;
}>;
export declare const Status: ContainerType<{
    forkDigest: import("@chainsafe/ssz").ByteVectorType;
    finalizedRoot: import("@chainsafe/ssz").ByteVectorType;
    finalizedEpoch: import("@chainsafe/ssz").UintNumberType;
    headRoot: import("@chainsafe/ssz").ByteVectorType;
    headSlot: import("@chainsafe/ssz").UintNumberType;
}>;
export declare const Goodbye: import("@chainsafe/ssz").UintBigintType;
export declare const Ping: import("@chainsafe/ssz").UintBigintType;
export declare const Metadata: ContainerType<{
    seqNumber: import("@chainsafe/ssz").UintBigintType;
    attnets: BitVectorType;
}>;
export declare const BeaconBlocksByRangeRequest: ContainerType<{
    startSlot: import("@chainsafe/ssz").UintNumberType;
    count: import("@chainsafe/ssz").UintNumberType;
    step: import("@chainsafe/ssz").UintNumberType;
}>;
export declare const BeaconBlocksByRootRequest: ListCompositeType<import("@chainsafe/ssz").ByteVectorType>;
export declare const Genesis: ContainerType<{
    genesisValidatorsRoot: import("@chainsafe/ssz").ByteVectorType;
    genesisTime: import("@chainsafe/ssz").UintNumberType;
    genesisForkVersion: import("@chainsafe/ssz").ByteVectorType;
}>;
//# sourceMappingURL=sszTypes.d.ts.map