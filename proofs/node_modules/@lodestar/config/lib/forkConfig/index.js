import { GENESIS_EPOCH, ForkName, SLOTS_PER_EPOCH, ForkSeq, isForkLightClient, isForkExecution, isForkBlobs, } from "@lodestar/params";
import { ssz } from "@lodestar/types";
export * from "./types.js";
export function createForkConfig(config) {
    const phase0 = {
        name: ForkName.phase0,
        seq: ForkSeq.phase0,
        epoch: GENESIS_EPOCH,
        version: config.GENESIS_FORK_VERSION,
        // Will never be used
        prevVersion: config.GENESIS_FORK_VERSION,
        prevForkName: ForkName.phase0,
    };
    const altair = {
        name: ForkName.altair,
        seq: ForkSeq.altair,
        epoch: config.ALTAIR_FORK_EPOCH,
        version: config.ALTAIR_FORK_VERSION,
        prevVersion: config.GENESIS_FORK_VERSION,
        prevForkName: ForkName.phase0,
    };
    const bellatrix = {
        name: ForkName.bellatrix,
        seq: ForkSeq.bellatrix,
        epoch: config.BELLATRIX_FORK_EPOCH,
        version: config.BELLATRIX_FORK_VERSION,
        prevVersion: config.ALTAIR_FORK_VERSION,
        prevForkName: ForkName.altair,
    };
    const capella = {
        name: ForkName.capella,
        seq: ForkSeq.capella,
        epoch: config.CAPELLA_FORK_EPOCH,
        version: config.CAPELLA_FORK_VERSION,
        prevVersion: config.BELLATRIX_FORK_VERSION,
        prevForkName: ForkName.bellatrix,
    };
    const deneb = {
        name: ForkName.deneb,
        seq: ForkSeq.deneb,
        epoch: config.DENEB_FORK_EPOCH,
        version: config.DENEB_FORK_VERSION,
        prevVersion: config.CAPELLA_FORK_VERSION,
        prevForkName: ForkName.capella,
    };
    /** Forks in order order of occurence, `phase0` first */
    // Note: Downstream code relies on proper ordering.
    const forks = { phase0, altair, bellatrix, capella, deneb };
    // Prevents allocating an array on every getForkInfo() call
    const forksAscendingEpochOrder = Object.values(forks);
    const forksDescendingEpochOrder = Object.values(forks).reverse();
    return {
        forks,
        forksAscendingEpochOrder,
        forksDescendingEpochOrder,
        // Fork convenience methods
        getForkInfo(slot) {
            const epoch = Math.floor(Math.max(slot, 0) / SLOTS_PER_EPOCH);
            // NOTE: forks must be sorted by descending epoch, latest fork first
            for (const fork of forksDescendingEpochOrder) {
                if (epoch >= fork.epoch)
                    return fork;
            }
            return phase0;
        },
        getForkName(slot) {
            return this.getForkInfo(slot).name;
        },
        getForkSeq(slot) {
            return this.getForkInfo(slot).seq;
        },
        getForkVersion(slot) {
            return this.getForkInfo(slot).version;
        },
        getForkTypes(slot) {
            return ssz.allForks[this.getForkName(slot)];
        },
        getExecutionForkTypes(slot) {
            const forkName = this.getForkName(slot);
            if (!isForkExecution(forkName)) {
                throw Error(`Invalid slot=${slot} fork=${forkName} for execution fork types`);
            }
            return ssz.allForksExecution[forkName];
        },
        getBlindedForkTypes(slot) {
            const forkName = this.getForkName(slot);
            if (!isForkExecution(forkName)) {
                throw Error(`Invalid slot=${slot} fork=${forkName} for blinded fork types`);
            }
            return ssz.allForksBlinded[forkName];
        },
        getLightClientForkTypes(slot) {
            const forkName = this.getForkName(slot);
            if (!isForkLightClient(forkName)) {
                throw Error(`Invalid slot=${slot} fork=${forkName} for lightclient fork types`);
            }
            return ssz.allForksLightClient[forkName];
        },
        getBlobsForkTypes(slot) {
            const forkName = this.getForkName(slot);
            if (!isForkBlobs(forkName)) {
                throw Error(`Invalid slot=${slot} fork=${forkName} for blobs fork types`);
            }
            return ssz.allForksBlobs[forkName];
        },
    };
}
//# sourceMappingURL=index.js.map